<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Ethereum Virtual Machine (in Rust) - Part 1 | 0xrusowsky</title>
<meta name=keywords content><meta name=description content="First chapter of the Ethereum, but made in Rust series. In this first episode, I explore the foundational building blocks of revm: a Rust implementation of the Ethereum Virtual Machine."><meta name=author content="0xrusowsky"><link rel=canonical href=https://0xrusowsky.github.io/blog/articles/revm-pt1/><link crossorigin=anonymous href=/blog/assets/css/stylesheet.dd1cff80f148fd6c7466d468a6d6ab404ef84727fccfdcd25233db853545848c.css integrity="sha256-3Rz/gPFI/Wx0ZtRoptarQE74Ryf8z9zSUjPbhTVFhIw=" rel="preload stylesheet" as=style><link rel=icon href=https://0xrusowsky.github.io/blog/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://0xrusowsky.github.io/blog/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://0xrusowsky.github.io/blog/favicon-32x32.png><link rel=apple-touch-icon href=https://0xrusowsky.github.io/blog/apple-touch-icon.png><link rel=mask-icon href=https://0xrusowsky.github.io/blog/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Ethereum Virtual Machine (in Rust) - Part 1"><meta property="og:description" content="First chapter of the Ethereum, but made in Rust series. In this first episode, I explore the foundational building blocks of revm: a Rust implementation of the Ethereum Virtual Machine."><meta property="og:type" content="article"><meta property="og:url" content="https://0xrusowsky.github.io/blog/articles/revm-pt1/"><meta property="article:section" content="articles"><meta property="article:published_time" content="2024-02-18T20:00:00+00:00"><meta property="article:modified_time" content="2024-02-18T20:00:00+00:00"><meta property="og:site_name" content="0xrusowsky"><meta name=twitter:card content="summary"><meta name=twitter:title content="Ethereum Virtual Machine (in Rust) - Part 1"><meta name=twitter:description content="First chapter of the Ethereum, but made in Rust series. In this first episode, I explore the foundational building blocks of revm: a Rust implementation of the Ethereum Virtual Machine."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Articles","item":"https://0xrusowsky.github.io/blog/articles/"},{"@type":"ListItem","position":2,"name":"Ethereum Virtual Machine (in Rust) - Part 1","item":"https://0xrusowsky.github.io/blog/articles/revm-pt1/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Ethereum Virtual Machine (in Rust) - Part 1","name":"Ethereum Virtual Machine (in Rust) - Part 1","description":"First chapter of the Ethereum, but made in Rust series. In this first episode, I explore the foundational building blocks of revm: a Rust implementation of the Ethereum Virtual Machine.","keywords":[],"articleBody":"What are Virtual Machines? At their core, VMs are software emulations of physical computers. They encapsulate an entire computing environment within a layer of abstraction that runs atop physical hardware. This design allows VMs to offer a sandboxed execution environment for applications, ensuring that software runs independently of the underlying hardware specifics. As you can tell, these properties are perfect for distributed systems aiming to decentralize their execution around the globe.\nBut how do they work? VMs are sophisticated programs that execute bytecode, a form of precompiled, low-level instructions designed for efficient execution by the VM. Each instruction consists of an operation code (opcode) and its arguments, guiding how the VM manipulates data and manages operations.\nThe execution process within a VM follows a simple yet powerful loop, with a program counter (PC) tracking its progress through the bytecode. Here’s a basic outline of this execution loop:\nFetch: Retrieve the instruction at the position indicated by the PC. Execute: Carry out the operation specified by the instruction, which may involve arithmetic calculations, memory access, or other data manipulations. Jump: If the instruction involves a jump, update the PC to point to the target instruction within the bytecode. Increment: Otherwise, simply advance the PC to the next opcode. Note that some opcodes may require inputs and that the PC can increment by more than 1 at a time. For instance, let’s disassemble 0x6000356020350160005260206000f3 into bytes. We will assume that the opcode 0x60 consumes 1 byte, and that there are no jump instructions within this bytecode.\nBytecode: 60 00 35 60 20 35 01 60 00 52 60 20 60 00 f3 PC: 0 0 2 3 3 5 6 7 7 9 10 10 12 12 14 This structured process ensures that, irrespective of the underlying hardware or any asynchronies, VMs produce consistent outcomes when executing the same bytecode, provided that the execution environment remains unchanged.\nMeet the Ethereum VM Ethereum, taken as a whole, can be viewed as a transaction-based state machine. In other words, a valid state transition is able to modify the state of the chain by carrying arbitrary computations. The execution model specifies how the system state is altered given a series of bytecode instructions and a small tuple of environmental data.\nAs described in Ethereum’s Yellow Paper, the EVM is the core of the execution layer. Providing a reproducible runtime environment that ensures unanimous agreement across the network on computation outcomes —which is key for the integrity of the blockchain—. Its design allows for the execution of smart contracts across distinct computing environments, thanks to a sandboxed environment tailored to Ethereum’s needs:\nEthereum-Specific Features: Such as unique storage models, execution contexts, and essential elliptic-curve signature functions for hashing. Gas Mechanism: Solving the halting problem by metering computation, ensuring all operations are finite and predictable. Cross-Contract Communication: Facilitating interactions between contracts via call and delegatecall mechanisms. EVM Basics The following section aims to explain the theory behind each of its components, as well as showcasing the essence of their revm implementation. Because of that, some of the provided snippets may differ from the original code, aiming to illustrate the foundational building blocks a developer would create when coding the EVM from scratch. As we delve into the intricacies of the yellow paper, we will refine these blocks to match the real revm implementation.\nEVM architecture and brief overview of its components.\nThe EVM is a stack-based machine that operates with a 1024-item-deep stack, where each item is a 256-bit word. It follows a big endian byte ordering convention.\nByte Primitive Types Bytes can be implemented as bit vectors Vec. If they have a predefined number of bits (i.e. addresses) as fixed-length arrays [u8; N]. The Ethereum \u003c\u003e Rust ecosystem relies on 2 main crates to handle byte primitive types: ruint and alloy-primitives. These crates define several types that reduce the burden of having to work with bytes, with built-in arithmetic and bitwise operations, as well as seamless conversion from one type to another. The most common types are:\n// Wrapper type around bytes::Bytes to support “0x” prefixed hex strings. // For simplicity, you can think of bytes::Bytes as an optimized impl of Vec. pub struct Bytes(pub Bytes); // A byte array of fixed length ([u8; N]). pub struct FixedBytes\u003cconst N: usize\u003e(pub [u8; N]); // 256-bit (32-byte) unsigned integer. An EVM word. pub type U256 = Uint\u003c256, 4\u003e; // 256-bit fixed-byte integer. An EVM word. pub type B256 = FixedBytes\u003c32\u003e; // An Ethereum address, 20 bytes in length. pub struct Address(pub FixedBytes\u003c20\u003e); // An Ethereum event log object. pub struct LogData { pub data: Bytes } // A log consists of an address, and some log data. pub struct Log\u003cT = LogData\u003e { pub address: Address, pub data: T, } As previously said, all these types come with convenient methods. Check the docs for further details.\nStack The stack is a linear data structure that operate in a last-in, first-out (LIFO) manner, where elements are added (pushed) and removed (popped) from the end of the sequence (top of the stack).\n/// EVM interpreter stack limit. pub const STACK_LIMIT: usize = 1024; /// EVM stack with [STACK_LIMIT] capacity of words. pub struct Stack { /// The underlying data of the stack. data: Vec\u003cU256\u003e, } impl Stack { /// Instantiate a new stack with the [default stack limit][STACK_LIMIT]. pub fn new() -\u003e Self { Self { // SAFETY: expansion functions assume that capacity is `STACK_LIMIT`. data: Vec::with_capacity(STACK_LIMIT), } } /// Push a new value onto the stack. /// If it exceeds the stack limit, returns `StackOverflow` error and /// leaves the stack unchanged. pub fn push(\u0026mut self, value: U256) -\u003e Result\u003c(), InstructionResult\u003e { // allows the compiler to optimize out the `Vec::push` capacity check assume!(self.data.capacity() == STACK_LIMIT); if self.data.len() == STACK_LIMIT { return Err(InstructionResult::StackOverflow); } self.data.push(value); Ok(()) } /// Removes the topmost element from the stack and returns it, or /// `StackUnderflow` if it is empty. pub fn pop(\u0026mut self) -\u003e Result\u003cU256, InstructionResult\u003e { self.data.pop().ok_or(InstructionResult::StackUnderflow) } } Memory During execution, the EVM utilizes volatile memory, functioning as a word-addressed byte array that resets after each transaction. This memory is linear and can be addressed by bytes (8 bits) or words (32 bytes or 256 bits), facilitating flexible data manipulation.\n/// A word-addressable memory, which uses a `Vec` for internal representation. /// A [Memory] instance should always be obtained using the `new` static method /// to ensure memory safety. pub struct Memory { /// The underlying buffer. buffer: Vec\u003cu8\u003e, /// Memory limit. See [`CfgEnv`](revm_primitives::CfgEnv). #[cfg(feature = \"memory_limit\")] memory_limit: u64, } impl Memory { /// Creates a new memory instance. The default initial capacity is 4KiB. pub fn new() -\u003e Self { Self::with_capacity(4 * 1024) // from evmone } /// Creates a new memory instance with the given `capacity`. pub fn with_capacity(capacity: usize) -\u003e Self { Self { buffer: Vec::with_capacity(capacity), #[cfg(feature = \"memory_limit\")] memory_limit: u64::MAX, } } } Since memory is a word-addressable byte array, its getter and setter methods require an offset and a size. Note that when setting a value, its size can be derived from its length.\nimpl Memory { /// Returns a byte slice of the memory region at the given offset. /// Panics on out of bounds. pub fn slice(\u0026self, offset: usize, size: usize) -\u003e \u0026[u8] { let end = offset + size; self.buffer .get(offset..offset + size) .unwrap() } /// Set memory region at given `offset`. /// Panics on out of bounds. pub fn set(\u0026mut self, offset: usize, value: \u0026[u8]) { if !value.is_empty() { self.slice_mut(offset, value.len()).copy_from_slice(value); } } /// Sets the given U256 `value` to the memory region at the given `offset`. /// Panics on out of bounds. pub fn set_u256(\u0026mut self, offset: usize, value: U256) { self.set(offset, \u0026value.to_be_bytes::\u003c32\u003e()); } } Finally, as memory can be expanded up to a max capacity, the implementation should also have a method to resize its buffer. Note that expansion only impacts memory size, the underlying data of the expanded section remains empty -it is filled with zeros-.\nimpl Memory { /// Resizes the memory in-place so that `len` is equal to `new_len`. pub fn resize(\u0026mut self, new_size: usize) { self.buffer.resize(new_size, 0); } } Storage The EVM also has a non-volatile storage model where each account (contract) keeps relevant information of the system state. The storage layout is like a hashmap that uses key-value pairs to access persistent data. Each contract has its own storage and -at the time of writing- can only interact with their own storage.\n/// An account's Storage is a mapping of 256-bit integer key-value pairs. pub type Storage = HashMap\u003cU256, U256\u003e; *Note that Hashmap is a type defined in the standard library. As such, among other convenient methods, it already has getter and setter functions. If you are not familiar with hashmaps yet, check its docs.\nWorld State The world state, or state trie, is a mapping between addresses and account states (account basic info and its storage). Although it is not stored on the blockchain -only the state root is stored in the block header-, the EVM has access to all this information stored in a state database. At the time of writing, Ethereum uses a data structure called modified merkle-patricia trie, which requires full-nodes to maintain the full chain state (not the history) on their local database. The following image is a nice visual representation of Ethereum’s tries where you can easily see the relationship between the account storage trie, an account’s basic info, and the world state trie.\n/// EVM State is a mapping from addresses to accounts. pub type State = HashMap\u003cAddress, Account\u003e; pub struct Account { /// Balance, nonce, and code. pub info: AccountInfo, /// Storage cache pub storage: Storage, /// Account status flags. pub status: AccountStatus, } // The `bitflags!` macro generates structs that manage a set of flags. bitflags! { pub struct AccountStatus: u8 { /// When account is loaded but not touched or interacted with. /// This is the default state. const Loaded = 0b00000000; /// When account is newly created we will not access database /// to fetch storage values const Created = 0b00000001; /// If account is marked for self destruction. const SelfDestructed = 0b00000010; /// Only when account is marked as touched we will save it to database. const Touched = 0b00000100; } } /// AccountInfo represents basic account information. pub struct AccountInfo { /// Account balance. pub balance: U256, /// Account nonce. pub nonce: u64, /// code hash, pub code_hash: B256, /// code: if None, `code_by_hash` will be used to fetch the code when needed. pub code: Option\u003cBytecode\u003e, } impl Default for AccountInfo { fn default() -\u003e Self { Self { balance: U256::ZERO, code_hash: KECCAK_EMPTY, code: Some(Bytecode::new()), nonce: 0, } } } To efficiently manage and store persistent data, a dedicated database is used. As revm aims to be a modular framework, a trait (rather than a type) is implemented. This design decision allows any user-desired db architecture to be used, as long as the Database trait is implemented.\n/// EVM database interface. pub trait Database { type Error; /// Get basic account information. fn basic(\u0026mut self, address: Address) -\u003e Result\u003cOption\u003cAccountInfo\u003e, Self::Error\u003e; /// Get account code by its hash. fn code_by_hash(\u0026mut self, code_hash: B256) -\u003e Result\u003cBytecode, Self::Error\u003e; /// Get storage value of address at index. fn storage(\u0026mut self, address: Address, index: U256) -\u003e Result\u003cU256, Self::Error\u003e; /// Get block hash by block number. fn block_hash(\u0026mut self, number: U256) -\u003e Result\u003cB256, Self::Error\u003e; } /// EVM database commit interface. pub trait DatabaseCommit { /// Commit changes to the database. fn commit(\u0026mut self, changes: HashMap\u003cAddress, Account\u003e); } When defining traits, it is recommended to provide different levels of mutability and ownership. Database requires mutable access (\u0026mut self) to perform state-altering operations. On the other hand, DatabaseRef is designed for immutable access (\u0026self), potentially allowing for concurrent read-only access.\n/// read-only EVM database interface. pub trait DatabaseRef { type Error; /// Get basic account information. fn basic_ref(\u0026self, address: Address) -\u003e Result\u003cOption\u003cAccountInfo\u003e, Self::Error\u003e; /// Get account code by its hash. fn code_by_hash_ref(\u0026self, code_hash: B256) -\u003e Result\u003cBytecode, Self::Error\u003e; /// Get storage value of address at index. fn storage_ref(\u0026self, address: Address, index: U256) -\u003e Result\u003cU256, Self::Error\u003e; /// Get block hash by block number. fn block_hash_ref(\u0026self, number: U256) -\u003e Result\u003cB256, Self::Error\u003e; } In order to minimize duplication of code and the amount of interfaces to support, the WrapDatabaseRef struct provides a way to adapt any implementation of DatabaseRef to fulfill the Database trait. This is particularly useful when you have a read-only implementation of a database that you want to use in a context where a mutable database interface is expected. The wrapper effectively bridges the gap between these two requirements without forcing the underlying database implementation to adopt mutability.\n/// Wraps a [`DatabaseRef`] to provide a [`Database`] implementation. pub struct WrapDatabaseRef\u003cT: DatabaseRef\u003e(pub T); /// Implement the wrapper around [`DatabaseRef`]. impl\u003cF: DatabaseRef\u003e From\u003cF\u003e for WrapDatabaseRef\u003cF\u003e { fn from(f: F) -\u003e Self { WrapDatabaseRef(f) } } /// Implement [`Database`] trait in an immutable manner. impl\u003cT: DatabaseRef\u003e Database for WrapDatabaseRef\u003cT\u003e { type Error = T::Error; fn basic(\u0026mut self, address: Address) -\u003e Result\u003cOption\u003cAccountInfo\u003e, Self::Error\u003e { self.0.basic_ref(address) } fn code_by_hash(\u0026mut self, code_hash: B256) -\u003e Result\u003cBytecode, Self::Error\u003e { self.0.code_by_hash_ref(code_hash) } fn storage(\u0026mut self, address: Address, index: U256) -\u003e Result\u003cU256, Self::Error\u003e { self.0.storage_ref(address, index) } fn block_hash(\u0026mut self, number: U256) -\u003e Result\u003cB256, Self::Error\u003e { self.0.block_hash_ref(number) } } Transient Storage As per EIP-1153, after the Cancun hard fork, the EVM will also implement transient storage. A new type of data storage mechanism that is identical to regular storage, but which is discarded after every transaction (only persists within a transaction). Its main application being cheaper reentrancy locks.\nThis difference between the two, means that the TransientStorage definition can be simplified. Rather than relying on a nested hashmap State \u003e Account [Storage] \u003e Slot, the key of the TransientStorage hashmap is a tuple composed by the account address, and the storage slot.\n/// Structure used for EIP-1153 transient storage. pub type TransientStorage = HashMap\u003c(Address, U256), U256\u003e; Gas As for computation costs, the EVM employs a mechanism pricing mechanism called gas. in order to execute a transaction, users must pay a gas fee to compensate for the computational resources they spend. By doing so, we can ensure that the network is not vulnerable to spam and cannot get stuck in infinite computational loops. The gas associated with each operation is different, and must be paid regardless of the outcome of the transaction, even if it reverts.\nApart from the computation costs, extra gas is charged to form the payment for a subordinate message call or contract creation (payment is embedded in the CREATE, CREATE2, CALL and CALLCODE opcodes).\nOn top of that, extra gas is also charged when expanding the memory. Since memory is word-addressable, its expansion happens in 32-byte bounds. Note that expansion will happen regardless of the nature of the memory operation (either read or write).\nFinally, to help address the state growth problem, gas refunds are given when storage slots are cleared.\n/// Represents the state of gas during execution. pub struct Gas { /// The initial gas limit. limit: u64, /// The total used gas. all_used_gas: u64, /// Used gas without memory expansion. used: u64, /// Used gas for memory expansion. memory: u64, /// Refunded gas. This is used only at the end of execution. refunded: i64, } With the introduction of EIP-1559 after the London hard fork, the fees paid by users are split between a base fee -common for all the txs in a block- and a user-defined priority fee. This change lowered the volatility in gas prices, and gave user better predictibility.\nTo learn more about gas fees (structure, limits, pricing, etc.) check the following article.\nExecution Environment Environmental data necessary for the execution of the state transition. This section is quite self-explanatory thanks to the verbose (great) comments of the revm contributors. Overall, it shouldn’t introduce new topics to people who are already familiar with the Ethereum network.\n/// EVM environment configuration. pub struct Env { /// Configuration of the block the transaction is in. pub block: BlockEnv, /// Configuration of the transaction that is being executed. pub tx: TxEnv, } /// The block environment. pub struct BlockEnv { /// The number of ancestor blocks of this block (block height). pub number: U256, /// Coinbase or miner or address that created and signed the block. /// This is the receiver address of all the gas spent in the block. pub coinbase: Address, /// The timestamp of the block in seconds since the UNIX epoch. pub timestamp: U256, /// The gas limit of the block. pub gas_limit: U256, /// The base fee per gas, added in the London upgrade with [EIP-1559]. pub basefee: U256, /// The difficulty of the block. /// Unused after Paris (AKA the merge) upgrade, and replaced by `prevrandao`. pub difficulty: U256, /// The output of the randomness beacon provided by the beacon chain. /// Replaces `difficulty` after Paris (AKA the merge) upgrade with [EIP-4399]. pub prevrandao: Option\u003cB256\u003e, /// Excess blob gas and blob gasprice. /// Incorporated as part of the Cancun upgrade via [EIP-4844]. pub blob_excess_gas_and_price: Option\u003cBlobExcessGasAndPrice\u003e, } /// The transaction environment. pub struct TxEnv { /// Caller aka Author aka transaction signer. pub caller: Address, /// The gas limit of the transaction. pub gas_limit: u64, /// The gas price of the transaction. pub gas_price: U256, /// The destination of the transaction. pub transact_to: TransactTo, /// The value sent to `transact_to`. pub value: U256, /// The calldata of the transaction. pub data: Bytes, /// The nonce of the transaction. If set to `None`, no checks are performed. pub nonce: Option\u003cu64\u003e, /// The chain ID of the tx. If set to `None`, no checks are performed. /// Incorporated as part of the Spurious Dragon upgrade via [EIP-155]. pub chain_id: Option\u003cu64\u003e, /// A list of addresses and storage keys that the transaction plans to access. /// Added in [EIP-2930]. pub access_list: Vec\u003c(Address, Vec\u003cU256\u003e)\u003e, /// The priority fee per gas. /// Incorporated as part of the London upgrade via [EIP-1559]. pub gas_priority_fee: Option\u003cU256\u003e, /// The list of blob versioned hashes. Per EIP there should be at least /// one blob present if [`Self::max_fee_per_blob_gas`] is `Some`. /// Incorporated as part of the Cancun upgrade via [EIP-4844]. pub blob_hashes: Vec\u003cB256\u003e, /// The max fee per blob gas. /// Incorporated as part of the Cancun upgrade via [EIP-4844]. pub max_fee_per_blob_gas: Option\u003cU256\u003e, } Note: The blob-related attributes refer to a new gas pricing mechanism for blob-carrying transactions. These are similar to regular transactions but include an additional set of data called blob (Binary Large Object). The main goal of this change is to allow roll-ups to still post their commitments on-chain. However, instead of doing it on the execution layer via calldata, they can do it on the beacon chain (consensus layer), where the blobs will be pruned in a couple of weeks. This pruning timeline gives enough time for provers to check the data commitments of the rollup and challenge them if necessary. For further detail check the proto-danksharding website.\nTransactTo is an enum that specifies the target of the transaction, which can be either a call or the creation of a new contract. Note that new contracts can be deterministically created by using a user-defined salt.\npub enum TransactTo { /// Simple call to an address. Call(Address), /// Contract creation. Create(CreateScheme), } pub enum CreateScheme { /// Legacy create scheme of `CREATE`. Create, /// Create scheme of `CREATE2`. Create2 { salt: U256 }, } EVM Execution The EVM’s deterministic nature ensures that Ethereum operates as a network with a state transition function. Given a current state and a series of transactions, it deterministically transitions to a new valid state.\nTransactions can only be triggered by externally-owned accounts (EOAs), and they either initiate message calls or deploy new contracts. In both cases, the stack is loaded with opcodes and data (from transaction calldata, memory, or storage) to execute instructions and transition to a new state.\nEVM execution model showcasing how the different components interact with each other.\nThe Interpreter As seen in the previous diagram, the interpreter is the core engine of the EVM. It is in charge of running the execution loop that processes and executes each of the instructions stored in the bytecode.\nBased on the above definition, we could label: program counter, stack, memory, and gas, as direct (internal) dependencies of the interpreter. Whereas storage, and the execution context, are somehow agnostic to it (external). Because of that, it seems reasonable to separate both implementations under different crates.\nThe Host This explicit separation, surfaces the need for an interface that facilitates the interaction of the EVM interpreter with its environment, encompassing essential operations such as accessing block, transaction or account data, accessing storage, or logging data. To fulfill this need, the Host trait has been created.\n/// EVM context host. pub trait Host { /// Returns a mutable reference to the environment. fn env(\u0026mut self) -\u003e \u0026mut Env; /// Loads an account. Returns (is_cold, is_new_account) fn load_account(\u0026mut self, address: Address) -\u003e Option\u003c(bool, bool)\u003e; /// Get the block hash of the given block `number`. fn block_hash(\u0026mut self, number: U256) -\u003e Option\u003cB256\u003e; /// Get balance of `address` and if the account is cold. fn balance(\u0026mut self, address: Address) -\u003e Option\u003c(U256, bool)\u003e; /// Get code of `address` and if the account is cold. fn code(\u0026mut self, address: Address) -\u003e Option\u003c(Bytecode, bool)\u003e; /// Get code hash of `address` and if the account is cold. fn code_hash(\u0026mut self, address: Address) -\u003e Option\u003c(B256, bool)\u003e; /// Get storage value of `address` at `index` and if the account is cold. fn sload(\u0026mut self, address: Address, index: U256) -\u003e Option\u003c(U256, bool)\u003e; /// Set storage value of account address at index. /// Returns (original, present, new, is_cold). fn sstore( \u0026mut self, address: Address, index: U256, value: U256, ) -\u003e Option\u003c(U256, U256, U256, bool)\u003e; /// Get the transient storage value of `address` at `index`. fn tload(\u0026mut self, address: Address, index: U256) -\u003e U256; /// Set the transient storage value of `address` at `index`. fn tstore(\u0026mut self, address: Address, index: U256, value: U256); /// Emit a log owned by `address` with given `LogData`. fn log(\u0026mut self, log: Log); /// Mark `address` to be deleted, with funds transferred to `target`. fn selfdestruct( \u0026mut self, address: Address, target: Address ) -\u003e Option\u003cSelfDestructResult\u003e; } This abstraction allows the interpreter to interact with any host environment -as long as the trait is implemented-, thereby enhancing modularity and interoperability. Different implementations can be used to simulate different environments when connecting to different EVM-compatible networks.\nA closing example In the next article of the series, we will review in detail how each opcode works. On the meantime, in order to further exemplify how the execution of an EVM transaction works, the following snippet showcases a representation of the bytecode that we initially disassembled: 0x6000356020350160005260206000f3.\nPC BYTECODE MNEMONIC STACK ACTION 0 60 00 PUSH1 0x00 [0x00] Push 0 to the stack. 2 35 CALLDATALOAD [num1] Load first 32 bytes on the stack. 3 60 20 PUSH1 0x20 [0x20, num1] Push 32 to the stack. 5 35 CALLDATALOAD [num2, num1] Load second 32 bytes on the stack. 6 01 ADD [n2+n1] Take 2 stack inputs and add them. 7 60 00 PUSH1 0x00 [0x0, n2+n1] Push 0 to the stack. 9 52 MSTORE [] Store n2+n1 with offset 0 in memory. 10 60 20 PUSH1 0x20 [0x20] Push 32 to the stack. 12 60 00 PUSH1 0x00 [0x00, 0x20] Push 0 to the stack. 14 f3 RETURN [] Return the first 32 bytes of memory. Given 64 bytes of calldata (2 words), and by executing our small bytecode with the EVM interpreter, we loaded them into the stack, added them, stored them in memory, and finally returned the output. Quite an achievement!\nThat’s a wrap! In this article, we’ve discussed the basics of the EVM, its high-level mechanics, and its core building blocks. Armed with this knowledge, we are better prepared to understand how these components interact with each other.\nMoving forward, in the next article, we will delve into the EVM interpreter, exploring its role and functionality in greater detail. Specifically, we will focus on the instruction set that powers the EVM.\n","wordCount":"4009","inLanguage":"en","datePublished":"2024-02-18T20:00:00Z","dateModified":"2024-02-18T20:00:00Z","author":{"@type":"Person","name":"0xrusowsky"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://0xrusowsky.github.io/blog/articles/revm-pt1/"},"publisher":{"@type":"Organization","name":"0xrusowsky","logo":{"@type":"ImageObject","url":"https://0xrusowsky.github.io/blog/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://0xrusowsky.github.io/blog/ accesskey=h title="0xrusowsky (Alt + H)"><img src=https://0xrusowsky.github.io/blog/images/rus.jpg alt aria-label=logo height=35>0xrusowsky</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://0xrusowsky.github.io/blog/articles/ title=Articles><span>Articles</span></a></li><li><a href=https://0xrusowsky.github.io/blog/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Ethereum Virtual Machine (in Rust) - Part 1</h1><div class=post-description>First chapter of the Ethereum, but made in Rust series. In this first episode, I explore the foundational building blocks of revm: a Rust implementation of the Ethereum Virtual Machine.</div><div class=post-meta><span title='2024-02-18 20:00:00 +0000 UTC'>February 18, 2024</span>&nbsp;·&nbsp;19 min&nbsp;·&nbsp;0xrusowsky</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#what-are-virtual-machines aria-label="What are Virtual Machines?">What are Virtual Machines?</a></li><li><a href=#meet-the-ethereum-vm aria-label="Meet the Ethereum VM">Meet the Ethereum VM</a></li><li><a href=#evm-basics aria-label="EVM Basics">EVM Basics</a><ul><li><a href=#byte-primitive-types aria-label="Byte Primitive Types">Byte Primitive Types</a></li><li><a href=#stack aria-label=Stack>Stack</a></li><li><a href=#memory aria-label=Memory>Memory</a></li><li><a href=#storage aria-label=Storage>Storage</a></li><li><a href=#world-state aria-label="World State">World State</a></li><li><a href=#transient-storage aria-label="Transient Storage">Transient Storage</a></li><li><a href=#gas aria-label=Gas>Gas</a></li><li><a href=#execution-environment aria-label="Execution Environment">Execution Environment</a></li></ul></li><li><a href=#evm-execution aria-label="EVM Execution">EVM Execution</a><ul><li><a href=#the-interpreter aria-label="The Interpreter">The Interpreter</a></li><li><a href=#the-host aria-label="The Host">The Host</a></li><li><a href=#a-closing-example aria-label="A closing example">A closing example</a></li></ul></li></ul></div></details></div><div class=post-content><h1 id=what-are-virtual-machines>What are Virtual Machines?<a hidden class=anchor aria-hidden=true href=#what-are-virtual-machines>#</a></h1><p>At their core, VMs are software emulations of physical computers. They encapsulate an entire computing environment within a layer of abstraction that runs atop physical hardware. This design allows VMs to offer a sandboxed execution environment for applications, ensuring that software runs independently of the underlying hardware specifics. As you can tell, these properties are perfect for distributed systems aiming to decentralize their execution around the globe.</p><p><em>But how do they work?</em> VMs are sophisticated programs that execute bytecode, a form of precompiled, low-level instructions designed for efficient execution by the VM. Each instruction consists of an operation code (opcode) and its arguments, guiding how the VM manipulates data and manages operations.</p><p>The execution process within a VM follows a simple yet powerful loop, with a program counter (PC) tracking its progress through the bytecode. Here’s a basic outline of this execution loop:</p><ol><li><strong>Fetch</strong>: Retrieve the instruction at the position indicated by the PC.</li><li><strong>Execute</strong>: Carry out the operation specified by the instruction, which may involve arithmetic calculations, memory access, or other data manipulations.</li><li><strong>Jump</strong>: If the instruction involves a jump, update the PC to point to the target instruction within the bytecode.</li><li><strong>Increment</strong>: Otherwise, simply advance the PC to the next opcode. <em>Note that some opcodes may require inputs and that the PC can increment by more than 1 at a time.</em></li></ol><p>For instance, let&rsquo;s disassemble <code>0x6000356020350160005260206000f3</code> into bytes. We will assume that the opcode <code>0x60</code> consumes 1 byte, and that there are no jump instructions within this bytecode.</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-md data-lang=md><span style=display:flex><span>Bytecode: 60 00 35 60 20 35 01 60 00 52 60 20 60 00 f3
</span></span><span style=display:flex><span>      PC: 0  0  2  3  3  5  6  7  7  9  10 10 12 12 14
</span></span></code></pre></div><p>This structured process ensures that, irrespective of the underlying hardware or any asynchronies, VMs produce consistent outcomes when executing the same bytecode, provided that the execution environment remains unchanged.</p><h1 id=meet-the-ethereum-vm>Meet the Ethereum VM<a hidden class=anchor aria-hidden=true href=#meet-the-ethereum-vm>#</a></h1><p>Ethereum, taken as a whole, can be viewed as a transaction-based state machine. In other words, a valid state transition is able to modify the state of the chain by carrying arbitrary computations. The execution model specifies how the system state is altered given a series of bytecode instructions and a small tuple of environmental data.</p><p>As described in <a href=https://ethereum.github.io/yellowpaper/paper.pdf>Ethereum&rsquo;s Yellow Paper</a>, the EVM is the core of the execution layer. Providing a reproducible runtime environment that ensures unanimous agreement across the network on computation outcomes —which is key for the integrity of the blockchain—.
Its design allows for the execution of smart contracts across distinct computing environments, thanks to a sandboxed environment tailored to Ethereum&rsquo;s needs:</p><ul><li><strong>Ethereum-Specific Features</strong>: Such as unique storage models, execution contexts, and essential elliptic-curve signature functions for hashing.</li><li><strong>Gas Mechanism</strong>: Solving the halting problem by metering computation, ensuring all operations are finite and predictable.</li><li><strong>Cross-Contract Communication</strong>: Facilitating interactions between contracts via call and delegatecall mechanisms.</li></ul><h1 id=evm-basics>EVM Basics<a hidden class=anchor aria-hidden=true href=#evm-basics>#</a></h1><p>The following section aims to explain the theory behind each of its components, as well as showcasing the essence of their <code>revm</code> implementation. Because of that, some of the provided snippets may differ from the original code, aiming to illustrate the foundational building blocks a developer would create when coding the EVM from scratch. As we delve into the intricacies of the yellow paper, we will refine these blocks to match the real <code>revm</code> implementation.</p><figure class=align-center><img loading=lazy src=/blog/images/revm/architecture.png#center alt="EVM architecture and brief overview of its components."><figcaption><p><em>EVM architecture and brief overview of its components.</em></p></figcaption></figure><p>The EVM is a stack-based machine that operates with a 1024-item-deep stack, where each item is a 256-bit word. It follows a <a href=https://developer.mozilla.org/en-US/docs/Glossary/Endianness>big endian</a> byte ordering convention.</p><h2 id=byte-primitive-types>Byte Primitive Types<a hidden class=anchor aria-hidden=true href=#byte-primitive-types>#</a></h2><p>Bytes can be implemented as bit vectors <code>Vec&lt;u8></code>. If they have a predefined number of bits (i.e. addresses) as fixed-length arrays <code>[u8; N]</code>.
The Ethereum &lt;> Rust ecosystem relies on 2 main crates to handle byte primitive types: <a href=https://github.com/recmo/uint>ruint</a> and <a href=https://github.com/alloy-rs/core/>alloy-primitives</a>. These crates define several types that reduce the burden of having to work with bytes, with built-in arithmetic and bitwise operations, as well as seamless conversion from one type to another. The most common types are:</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rs data-lang=rs><span style=display:flex><span><span style=color:#6c7086;font-style:italic>// Wrapper type around bytes::Bytes to support “0x” prefixed hex strings.
</span></span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic>// For simplicity, you can think of bytes::Bytes as an optimized impl of Vec&lt;u8&gt;.
</span></span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic></span><span style=color:#cba6f7>pub</span> <span style=color:#cba6f7>struct</span> <span style=color:#f9e2af>Bytes</span>(<span style=color:#cba6f7>pub</span> Bytes);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic>// A byte array of fixed length ([u8; N]).
</span></span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic></span><span style=color:#cba6f7>pub</span> <span style=color:#cba6f7>struct</span> <span style=color:#f9e2af>FixedBytes</span><span style=color:#89dceb;font-weight:700>&lt;</span><span style=color:#cba6f7>const</span> N: <span style=color:#f38ba8>usize</span><span style=color:#89dceb;font-weight:700>&gt;</span>(<span style=color:#cba6f7>pub</span> [<span style=color:#f38ba8>u8</span>; N]);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic>// 256-bit (32-byte) unsigned integer. An EVM word.
</span></span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic></span><span style=color:#cba6f7>pub</span> <span style=color:#cba6f7>type</span> <span style=color:#f9e2af>U256</span> <span style=color:#89dceb;font-weight:700>=</span> Uint<span style=color:#89dceb;font-weight:700>&lt;</span><span style=color:#fab387>256</span>, <span style=color:#fab387>4</span><span style=color:#89dceb;font-weight:700>&gt;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic>// 256-bit fixed-byte integer. An EVM word.
</span></span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic></span><span style=color:#cba6f7>pub</span> <span style=color:#cba6f7>type</span> <span style=color:#f9e2af>B256</span> <span style=color:#89dceb;font-weight:700>=</span> FixedBytes<span style=color:#89dceb;font-weight:700>&lt;</span><span style=color:#fab387>32</span><span style=color:#89dceb;font-weight:700>&gt;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic>// An Ethereum address, 20 bytes in length.
</span></span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic></span><span style=color:#cba6f7>pub</span> <span style=color:#cba6f7>struct</span> <span style=color:#f9e2af>Address</span>(<span style=color:#cba6f7>pub</span> FixedBytes<span style=color:#89dceb;font-weight:700>&lt;</span><span style=color:#fab387>20</span><span style=color:#89dceb;font-weight:700>&gt;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic>// An Ethereum event log object.
</span></span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic></span><span style=color:#cba6f7>pub</span> <span style=color:#cba6f7>struct</span> <span style=color:#f9e2af>LogData</span> { <span style=color:#cba6f7>pub</span> data: <span style=color:#f9e2af>Bytes</span> }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic>// A log consists of an address, and some log data.
</span></span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic></span><span style=color:#cba6f7>pub</span> <span style=color:#cba6f7>struct</span> <span style=color:#f9e2af>Log</span><span style=color:#89dceb;font-weight:700>&lt;</span>T <span style=color:#89dceb;font-weight:700>=</span> LogData<span style=color:#89dceb;font-weight:700>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>pub</span> address: <span style=color:#f9e2af>Address</span>,
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>pub</span> data: <span style=color:#f9e2af>T</span>,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>As previously said, all these types come with convenient methods. <a href=https://docs.rs/alloy-primitives/latest/alloy_primitives/>Check the docs</a> for further details.</p><h2 id=stack>Stack<a hidden class=anchor aria-hidden=true href=#stack>#</a></h2><p>The stack is a linear data structure that operate in a last-in, first-out (LIFO) manner, where elements are added (pushed) and removed (popped) from the end of the sequence (top of the stack).</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rs data-lang=rs><span style=display:flex><span><span style=color:#6c7086>/// EVM interpreter stack limit.
</span></span></span><span style=display:flex><span><span style=color:#6c7086></span><span style=color:#cba6f7>pub</span> <span style=color:#cba6f7>const</span> <span style=color:#f9e2af>STACK_LIMIT</span>: <span style=color:#f38ba8>usize</span> <span style=color:#89dceb;font-weight:700>=</span> <span style=color:#fab387>1024</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6c7086>/// EVM stack with [STACK_LIMIT] capacity of words.
</span></span></span><span style=display:flex><span><span style=color:#6c7086></span><span style=color:#cba6f7>pub</span> <span style=color:#cba6f7>struct</span> <span style=color:#f9e2af>Stack</span> {
</span></span><span style=display:flex><span>    <span style=color:#6c7086>/// The underlying data of the stack.
</span></span></span><span style=display:flex><span><span style=color:#6c7086></span>    data: <span style=color:#89dceb>Vec</span><span style=color:#89dceb;font-weight:700>&lt;</span>U256<span style=color:#89dceb;font-weight:700>&gt;</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#cba6f7>impl</span> Stack {
</span></span><span style=display:flex><span>    <span style=color:#6c7086>/// Instantiate a new stack with the [default stack limit][STACK_LIMIT].
</span></span></span><span style=display:flex><span><span style=color:#6c7086></span>    <span style=color:#cba6f7>pub</span> <span style=color:#cba6f7>fn</span> <span style=color:#89b4fa>new</span>() -&gt; <span style=color:#f9e2af>Self</span> {
</span></span><span style=display:flex><span>        <span style=color:#89dceb>Self</span> {
</span></span><span style=display:flex><span>            <span style=color:#6c7086;font-style:italic>// SAFETY: expansion functions assume that capacity is `STACK_LIMIT`.
</span></span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic></span>            data: <span style=color:#89dceb>Vec</span>::with_capacity(<span style=color:#f9e2af>STACK_LIMIT</span>),
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6c7086>/// Push a new value onto the stack.
</span></span></span><span style=display:flex><span><span style=color:#6c7086></span>    <span style=color:#6c7086>/// If it exceeds the stack limit, returns `StackOverflow` error and
</span></span></span><span style=display:flex><span><span style=color:#6c7086></span>    <span style=color:#6c7086>/// leaves the stack unchanged.
</span></span></span><span style=display:flex><span><span style=color:#6c7086></span>    <span style=color:#cba6f7>pub</span> <span style=color:#cba6f7>fn</span> <span style=color:#89b4fa>push</span>(<span style=color:#89dceb;font-weight:700>&amp;</span><span style=color:#cba6f7>mut</span> <span style=color:#89dceb>self</span>, value: <span style=color:#f9e2af>U256</span>) -&gt; <span style=color:#89dceb>Result</span><span style=color:#89dceb;font-weight:700>&lt;</span>(), InstructionResult<span style=color:#89dceb;font-weight:700>&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#6c7086;font-style:italic>// allows the compiler to optimize out the `Vec::push` capacity check
</span></span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic></span>        <span style=color:#89b4fa>assume!</span>(<span style=color:#89dceb>self</span>.data.capacity() <span style=color:#89dceb;font-weight:700>==</span> <span style=color:#f9e2af>STACK_LIMIT</span>);
</span></span><span style=display:flex><span>        <span style=color:#cba6f7>if</span> <span style=color:#89dceb>self</span>.data.len() <span style=color:#89dceb;font-weight:700>==</span> <span style=color:#f9e2af>STACK_LIMIT</span> {
</span></span><span style=display:flex><span>            <span style=color:#cba6f7>return</span> <span style=color:#89dceb>Err</span>(InstructionResult::StackOverflow);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#89dceb>self</span>.data.push(value);
</span></span><span style=display:flex><span>        <span style=color:#89dceb>Ok</span>(())
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6c7086>/// Removes the topmost element from the stack and returns it, or
</span></span></span><span style=display:flex><span><span style=color:#6c7086></span>    <span style=color:#6c7086>/// `StackUnderflow` if it is empty.
</span></span></span><span style=display:flex><span><span style=color:#6c7086></span>    <span style=color:#cba6f7>pub</span> <span style=color:#cba6f7>fn</span> <span style=color:#89b4fa>pop</span>(<span style=color:#89dceb;font-weight:700>&amp;</span><span style=color:#cba6f7>mut</span> <span style=color:#89dceb>self</span>) -&gt; <span style=color:#89dceb>Result</span><span style=color:#89dceb;font-weight:700>&lt;</span>U256, InstructionResult<span style=color:#89dceb;font-weight:700>&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#89dceb>self</span>.data.pop().ok_or(InstructionResult::StackUnderflow)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=memory>Memory<a hidden class=anchor aria-hidden=true href=#memory>#</a></h2><p>During execution, the EVM utilizes <strong>volatile memory</strong>, functioning as a <strong>word-addressed byte array</strong> that resets after each transaction. This memory is linear and can be addressed by bytes (8 bits) or words (32 bytes or 256 bits), facilitating flexible data manipulation.</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rs data-lang=rs><span style=display:flex><span><span style=color:#6c7086>/// A word-addressable memory, which uses a `Vec` for internal representation.
</span></span></span><span style=display:flex><span><span style=color:#6c7086>/// A [Memory] instance should always be obtained using the `new` static method
</span></span></span><span style=display:flex><span><span style=color:#6c7086>/// to ensure memory safety.
</span></span></span><span style=display:flex><span><span style=color:#6c7086></span><span style=color:#cba6f7>pub</span> <span style=color:#cba6f7>struct</span> <span style=color:#f9e2af>Memory</span> {
</span></span><span style=display:flex><span>    <span style=color:#6c7086>/// The underlying buffer.
</span></span></span><span style=display:flex><span><span style=color:#6c7086></span>    buffer: <span style=color:#89dceb>Vec</span><span style=color:#89dceb;font-weight:700>&lt;</span><span style=color:#f38ba8>u8</span><span style=color:#89dceb;font-weight:700>&gt;</span>,
</span></span><span style=display:flex><span>    <span style=color:#6c7086>/// Memory limit. See [`CfgEnv`](revm_primitives::CfgEnv).
</span></span></span><span style=display:flex><span><span style=color:#6c7086></span>    <span style=color:#6c7086;font-style:italic>#[cfg(feature = </span><span style=color:#a6e3a1>&#34;memory_limit&#34;</span><span style=color:#6c7086;font-style:italic>)]</span>
</span></span><span style=display:flex><span>    memory_limit: <span style=color:#f38ba8>u64</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#cba6f7>impl</span> Memory {
</span></span><span style=display:flex><span>    <span style=color:#6c7086>/// Creates a new memory instance. The default initial capacity is 4KiB.
</span></span></span><span style=display:flex><span><span style=color:#6c7086></span>    <span style=color:#cba6f7>pub</span> <span style=color:#cba6f7>fn</span> <span style=color:#89b4fa>new</span>() -&gt; <span style=color:#f9e2af>Self</span> {
</span></span><span style=display:flex><span>        <span style=color:#89dceb>Self</span>::with_capacity(<span style=color:#fab387>4</span> <span style=color:#89dceb;font-weight:700>*</span> <span style=color:#fab387>1024</span>) <span style=color:#6c7086;font-style:italic>// from evmone
</span></span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic></span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6c7086>/// Creates a new memory instance with the given `capacity`.
</span></span></span><span style=display:flex><span><span style=color:#6c7086></span>    <span style=color:#cba6f7>pub</span> <span style=color:#cba6f7>fn</span> <span style=color:#89b4fa>with_capacity</span>(capacity: <span style=color:#f38ba8>usize</span>) -&gt; <span style=color:#f9e2af>Self</span> {
</span></span><span style=display:flex><span>        <span style=color:#89dceb>Self</span> {
</span></span><span style=display:flex><span>            buffer: <span style=color:#89dceb>Vec</span>::with_capacity(capacity),
</span></span><span style=display:flex><span>            <span style=color:#6c7086;font-style:italic>#[cfg(feature = </span><span style=color:#a6e3a1>&#34;memory_limit&#34;</span><span style=color:#6c7086;font-style:italic>)]</span>
</span></span><span style=display:flex><span>            memory_limit: <span style=color:#f38ba8>u64</span>::<span style=color:#f9e2af>MAX</span>,
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Since memory is a word-addressable byte array, its getter and setter methods require an <code>offset</code> and a <code>size</code>. Note that when setting a value, its size can be derived from its length.</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rs data-lang=rs><span style=display:flex><span><span style=color:#cba6f7>impl</span> Memory {
</span></span><span style=display:flex><span>    <span style=color:#6c7086>/// Returns a byte slice of the memory region at the given offset.
</span></span></span><span style=display:flex><span><span style=color:#6c7086></span>    <span style=color:#6c7086>/// Panics on out of bounds.
</span></span></span><span style=display:flex><span><span style=color:#6c7086></span>    <span style=color:#cba6f7>pub</span> <span style=color:#cba6f7>fn</span> <span style=color:#89b4fa>slice</span>(<span style=color:#89dceb;font-weight:700>&amp;</span><span style=color:#89dceb>self</span>, offset: <span style=color:#f38ba8>usize</span>, size: <span style=color:#f38ba8>usize</span>) -&gt; <span style=color:#cba6f7>&amp;</span>[<span style=color:#f38ba8>u8</span>] {
</span></span><span style=display:flex><span>        <span style=color:#f38ba8>let</span> end <span style=color:#89dceb;font-weight:700>=</span> offset <span style=color:#89dceb;font-weight:700>+</span> size;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#89dceb>self</span>.buffer
</span></span><span style=display:flex><span>            .get(offset<span style=color:#89dceb;font-weight:700>..</span>offset <span style=color:#89dceb;font-weight:700>+</span> size)
</span></span><span style=display:flex><span>            .unwrap()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6c7086>/// Set memory region at given `offset`.
</span></span></span><span style=display:flex><span><span style=color:#6c7086></span>    <span style=color:#6c7086>/// Panics on out of bounds.
</span></span></span><span style=display:flex><span><span style=color:#6c7086></span>    <span style=color:#cba6f7>pub</span> <span style=color:#cba6f7>fn</span> <span style=color:#89b4fa>set</span>(<span style=color:#89dceb;font-weight:700>&amp;</span><span style=color:#cba6f7>mut</span> <span style=color:#89dceb>self</span>, offset: <span style=color:#f38ba8>usize</span>, value: <span style=color:#cba6f7>&amp;</span>[<span style=color:#f38ba8>u8</span>]) {
</span></span><span style=display:flex><span>        <span style=color:#cba6f7>if</span> <span style=color:#89dceb;font-weight:700>!</span>value.is_empty() {
</span></span><span style=display:flex><span>            <span style=color:#89dceb>self</span>.slice_mut(offset, value.len()).copy_from_slice(value);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6c7086>/// Sets the given U256 `value` to the memory region at the given `offset`.
</span></span></span><span style=display:flex><span><span style=color:#6c7086></span>    <span style=color:#6c7086>/// Panics on out of bounds.
</span></span></span><span style=display:flex><span><span style=color:#6c7086></span>    <span style=color:#cba6f7>pub</span> <span style=color:#cba6f7>fn</span> <span style=color:#89b4fa>set_u256</span>(<span style=color:#89dceb;font-weight:700>&amp;</span><span style=color:#cba6f7>mut</span> <span style=color:#89dceb>self</span>, offset: <span style=color:#f38ba8>usize</span>, value: <span style=color:#f9e2af>U256</span>) {
</span></span><span style=display:flex><span>        <span style=color:#89dceb>self</span>.set(offset, <span style=color:#89dceb;font-weight:700>&amp;</span>value.to_be_bytes::<span style=color:#89dceb;font-weight:700>&lt;</span><span style=color:#fab387>32</span><span style=color:#89dceb;font-weight:700>&gt;</span>());
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Finally, as memory can be expanded up to a max capacity, the implementation should also have a method to resize its buffer. Note that expansion only impacts memory size, the underlying data of the expanded section remains empty -it is filled with zeros-.</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rs data-lang=rs><span style=display:flex><span><span style=color:#cba6f7>impl</span> Memory {
</span></span><span style=display:flex><span>    <span style=color:#6c7086>/// Resizes the memory in-place so that `len` is equal to `new_len`.
</span></span></span><span style=display:flex><span><span style=color:#6c7086></span>    <span style=color:#cba6f7>pub</span> <span style=color:#cba6f7>fn</span> <span style=color:#89b4fa>resize</span>(<span style=color:#89dceb;font-weight:700>&amp;</span><span style=color:#cba6f7>mut</span> <span style=color:#89dceb>self</span>, new_size: <span style=color:#f38ba8>usize</span>) {
</span></span><span style=display:flex><span>        <span style=color:#89dceb>self</span>.buffer.resize(new_size, <span style=color:#fab387>0</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=storage>Storage<a hidden class=anchor aria-hidden=true href=#storage>#</a></h2><p>The EVM also has a <strong>non-volatile storage</strong> model where each account (contract) keeps relevant information of the system state. The storage layout is like a hashmap that uses <strong>key-value pairs</strong> to access <strong>persistent</strong> data. Each contract has its own storage and -at the time of writing- can only interact with their own storage.</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rs data-lang=rs><span style=display:flex><span><span style=color:#6c7086>/// An account&#39;s Storage is a mapping of 256-bit integer key-value pairs.
</span></span></span><span style=display:flex><span><span style=color:#6c7086></span><span style=color:#cba6f7>pub</span> <span style=color:#cba6f7>type</span> <span style=color:#f9e2af>Storage</span> <span style=color:#89dceb;font-weight:700>=</span> HashMap<span style=color:#89dceb;font-weight:700>&lt;</span>U256, U256<span style=color:#89dceb;font-weight:700>&gt;</span>;
</span></span></code></pre></div><p><em>*Note that <code>Hashmap</code> is a type defined in the standard library. As such, among other convenient methods, it already has getter and setter functions. If you are not familiar with hashmaps yet, <a href=https://doc.rust-lang.org/std/collections/struct.HashMap.html>check its docs</a>.</em></p><h2 id=world-state>World State<a hidden class=anchor aria-hidden=true href=#world-state>#</a></h2><p>The world state, or state trie, is a mapping between addresses and account states (account basic info and its storage). Although it is not stored on the blockchain -only the state root is stored in the block header-, the EVM has access to all this information stored in a state database. At the time of writing, Ethereum uses a data structure called modified merkle-patricia trie, which requires full-nodes to maintain the full chain state (not the history) on their local database. The <a href=https://i.stack.imgur.com/afWDt.jpg>following image</a> is a nice visual representation of Ethereum&rsquo;s tries where you can easily see the relationship between the account storage trie, an account&rsquo;s basic info, and the world state trie.</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rs data-lang=rs><span style=display:flex><span><span style=color:#6c7086>/// EVM State is a mapping from addresses to accounts.
</span></span></span><span style=display:flex><span><span style=color:#6c7086></span><span style=color:#cba6f7>pub</span> <span style=color:#cba6f7>type</span> <span style=color:#f9e2af>State</span> <span style=color:#89dceb;font-weight:700>=</span> HashMap<span style=color:#89dceb;font-weight:700>&lt;</span>Address, Account<span style=color:#89dceb;font-weight:700>&gt;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#cba6f7>pub</span> <span style=color:#cba6f7>struct</span> <span style=color:#f9e2af>Account</span> {
</span></span><span style=display:flex><span>    <span style=color:#6c7086>/// Balance, nonce, and code.
</span></span></span><span style=display:flex><span><span style=color:#6c7086></span>    <span style=color:#cba6f7>pub</span> info: <span style=color:#f9e2af>AccountInfo</span>,
</span></span><span style=display:flex><span>    <span style=color:#6c7086>/// Storage cache
</span></span></span><span style=display:flex><span><span style=color:#6c7086></span>    <span style=color:#cba6f7>pub</span> storage: <span style=color:#f9e2af>Storage</span>,
</span></span><span style=display:flex><span>    <span style=color:#6c7086>/// Account status flags.
</span></span></span><span style=display:flex><span><span style=color:#6c7086></span>    <span style=color:#cba6f7>pub</span> status: <span style=color:#f9e2af>AccountStatus</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic>// The `bitflags!` macro generates structs that manage a set of flags.
</span></span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic></span><span style=color:#89b4fa>bitflags!</span> {
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>pub</span> <span style=color:#cba6f7>struct</span> <span style=color:#f9e2af>AccountStatus</span>: <span style=color:#f38ba8>u8</span> {
</span></span><span style=display:flex><span>        <span style=color:#6c7086>/// When account is loaded but not touched or interacted with.
</span></span></span><span style=display:flex><span><span style=color:#6c7086></span>        <span style=color:#6c7086>/// This is the default state.
</span></span></span><span style=display:flex><span><span style=color:#6c7086></span>        <span style=color:#cba6f7>const</span> Loaded <span style=color:#89dceb;font-weight:700>=</span> <span style=color:#fab387>0b00000000</span>;
</span></span><span style=display:flex><span>        <span style=color:#6c7086>/// When account is newly created we will not access database
</span></span></span><span style=display:flex><span><span style=color:#6c7086></span>        <span style=color:#6c7086>/// to fetch storage values
</span></span></span><span style=display:flex><span><span style=color:#6c7086></span>        <span style=color:#cba6f7>const</span> Created <span style=color:#89dceb;font-weight:700>=</span> <span style=color:#fab387>0b00000001</span>;
</span></span><span style=display:flex><span>        <span style=color:#6c7086>/// If account is marked for self destruction.
</span></span></span><span style=display:flex><span><span style=color:#6c7086></span>        <span style=color:#cba6f7>const</span> SelfDestructed <span style=color:#89dceb;font-weight:700>=</span> <span style=color:#fab387>0b00000010</span>;
</span></span><span style=display:flex><span>        <span style=color:#6c7086>/// Only when account is marked as touched we will save it to database.
</span></span></span><span style=display:flex><span><span style=color:#6c7086></span>        <span style=color:#cba6f7>const</span> Touched <span style=color:#89dceb;font-weight:700>=</span> <span style=color:#fab387>0b00000100</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6c7086>/// AccountInfo represents basic account information.
</span></span></span><span style=display:flex><span><span style=color:#6c7086></span><span style=color:#cba6f7>pub</span> <span style=color:#cba6f7>struct</span> <span style=color:#f9e2af>AccountInfo</span> {
</span></span><span style=display:flex><span>    <span style=color:#6c7086>/// Account balance.
</span></span></span><span style=display:flex><span><span style=color:#6c7086></span>    <span style=color:#cba6f7>pub</span> balance: <span style=color:#f9e2af>U256</span>,
</span></span><span style=display:flex><span>    <span style=color:#6c7086>/// Account nonce.
</span></span></span><span style=display:flex><span><span style=color:#6c7086></span>    <span style=color:#cba6f7>pub</span> nonce: <span style=color:#f38ba8>u64</span>,
</span></span><span style=display:flex><span>    <span style=color:#6c7086>/// code hash,
</span></span></span><span style=display:flex><span><span style=color:#6c7086></span>    <span style=color:#cba6f7>pub</span> code_hash: <span style=color:#f9e2af>B256</span>,
</span></span><span style=display:flex><span>    <span style=color:#6c7086>/// code: if None, `code_by_hash` will be used to fetch the code when needed.
</span></span></span><span style=display:flex><span><span style=color:#6c7086></span>    <span style=color:#cba6f7>pub</span> code: <span style=color:#89dceb>Option</span><span style=color:#89dceb;font-weight:700>&lt;</span>Bytecode<span style=color:#89dceb;font-weight:700>&gt;</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#cba6f7>impl</span> <span style=color:#89dceb>Default</span> <span style=color:#cba6f7>for</span> AccountInfo {
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>fn</span> <span style=color:#89b4fa>default</span>() -&gt; <span style=color:#f9e2af>Self</span> {
</span></span><span style=display:flex><span>        <span style=color:#89dceb>Self</span> {
</span></span><span style=display:flex><span>            balance: <span style=color:#f9e2af>U256</span>::<span style=color:#f9e2af>ZERO</span>,
</span></span><span style=display:flex><span>            code_hash: <span style=color:#f9e2af>KECCAK_EMPTY</span>,
</span></span><span style=display:flex><span>            code: <span style=color:#89dceb>Some</span>(Bytecode::new()),
</span></span><span style=display:flex><span>            nonce: <span style=color:#fab387>0</span>,
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>To efficiently manage and store persistent data, a dedicated database is used. As <code>revm</code> aims to be a modular framework, a trait (rather than a type) is implemented. This design decision allows any user-desired db architecture to be used, as long as the <code>Database</code> trait is implemented.</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rs data-lang=rs><span style=display:flex><span><span style=color:#6c7086>/// EVM database interface.
</span></span></span><span style=display:flex><span><span style=color:#6c7086></span><span style=color:#cba6f7>pub</span> <span style=color:#cba6f7>trait</span> Database {
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>type</span> <span style=color:#f9e2af>Error</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6c7086>/// Get basic account information.
</span></span></span><span style=display:flex><span><span style=color:#6c7086></span>    <span style=color:#cba6f7>fn</span> <span style=color:#89b4fa>basic</span>(<span style=color:#89dceb;font-weight:700>&amp;</span><span style=color:#cba6f7>mut</span> <span style=color:#89dceb>self</span>, address: <span style=color:#f9e2af>Address</span>) -&gt; <span style=color:#89dceb>Result</span><span style=color:#89dceb;font-weight:700>&lt;</span><span style=color:#89dceb>Option</span><span style=color:#89dceb;font-weight:700>&lt;</span>AccountInfo<span style=color:#89dceb;font-weight:700>&gt;</span>, <span style=color:#89dceb>Self</span>::Error<span style=color:#89dceb;font-weight:700>&gt;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6c7086>/// Get account code by its hash.
</span></span></span><span style=display:flex><span><span style=color:#6c7086></span>    <span style=color:#cba6f7>fn</span> <span style=color:#89b4fa>code_by_hash</span>(<span style=color:#89dceb;font-weight:700>&amp;</span><span style=color:#cba6f7>mut</span> <span style=color:#89dceb>self</span>, code_hash: <span style=color:#f9e2af>B256</span>) -&gt; <span style=color:#89dceb>Result</span><span style=color:#89dceb;font-weight:700>&lt;</span>Bytecode, <span style=color:#89dceb>Self</span>::Error<span style=color:#89dceb;font-weight:700>&gt;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6c7086>/// Get storage value of address at index.
</span></span></span><span style=display:flex><span><span style=color:#6c7086></span>    <span style=color:#cba6f7>fn</span> <span style=color:#89b4fa>storage</span>(<span style=color:#89dceb;font-weight:700>&amp;</span><span style=color:#cba6f7>mut</span> <span style=color:#89dceb>self</span>, address: <span style=color:#f9e2af>Address</span>, index: <span style=color:#f9e2af>U256</span>) -&gt; <span style=color:#89dceb>Result</span><span style=color:#89dceb;font-weight:700>&lt;</span>U256, <span style=color:#89dceb>Self</span>::Error<span style=color:#89dceb;font-weight:700>&gt;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6c7086>/// Get block hash by block number.
</span></span></span><span style=display:flex><span><span style=color:#6c7086></span>    <span style=color:#cba6f7>fn</span> <span style=color:#89b4fa>block_hash</span>(<span style=color:#89dceb;font-weight:700>&amp;</span><span style=color:#cba6f7>mut</span> <span style=color:#89dceb>self</span>, number: <span style=color:#f9e2af>U256</span>) -&gt; <span style=color:#89dceb>Result</span><span style=color:#89dceb;font-weight:700>&lt;</span>B256, <span style=color:#89dceb>Self</span>::Error<span style=color:#89dceb;font-weight:700>&gt;</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6c7086>/// EVM database commit interface.
</span></span></span><span style=display:flex><span><span style=color:#6c7086></span><span style=color:#cba6f7>pub</span> <span style=color:#cba6f7>trait</span> DatabaseCommit {
</span></span><span style=display:flex><span>    <span style=color:#6c7086>/// Commit changes to the database.
</span></span></span><span style=display:flex><span><span style=color:#6c7086></span>    <span style=color:#cba6f7>fn</span> <span style=color:#89b4fa>commit</span>(<span style=color:#89dceb;font-weight:700>&amp;</span><span style=color:#cba6f7>mut</span> <span style=color:#89dceb>self</span>, changes: <span style=color:#f9e2af>HashMap</span><span style=color:#89dceb;font-weight:700>&lt;</span>Address, Account<span style=color:#89dceb;font-weight:700>&gt;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>When defining traits, it is recommended to provide different levels of mutability and ownership. <code>Database</code> requires mutable access <code>(&amp;mut self)</code> to perform state-altering operations. On the other hand, <code>DatabaseRef</code> is designed for immutable access <code>(&amp;self)</code>, potentially allowing for concurrent read-only access.</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rs data-lang=rs><span style=display:flex><span><span style=color:#6c7086>/// read-only EVM database interface.
</span></span></span><span style=display:flex><span><span style=color:#6c7086></span><span style=color:#cba6f7>pub</span> <span style=color:#cba6f7>trait</span> DatabaseRef {
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>type</span> <span style=color:#f9e2af>Error</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6c7086>/// Get basic account information.
</span></span></span><span style=display:flex><span><span style=color:#6c7086></span>    <span style=color:#cba6f7>fn</span> <span style=color:#89b4fa>basic_ref</span>(<span style=color:#89dceb;font-weight:700>&amp;</span><span style=color:#89dceb>self</span>, address: <span style=color:#f9e2af>Address</span>) -&gt; <span style=color:#89dceb>Result</span><span style=color:#89dceb;font-weight:700>&lt;</span><span style=color:#89dceb>Option</span><span style=color:#89dceb;font-weight:700>&lt;</span>AccountInfo<span style=color:#89dceb;font-weight:700>&gt;</span>, <span style=color:#89dceb>Self</span>::Error<span style=color:#89dceb;font-weight:700>&gt;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6c7086>/// Get account code by its hash.
</span></span></span><span style=display:flex><span><span style=color:#6c7086></span>    <span style=color:#cba6f7>fn</span> <span style=color:#89b4fa>code_by_hash_ref</span>(<span style=color:#89dceb;font-weight:700>&amp;</span><span style=color:#89dceb>self</span>, code_hash: <span style=color:#f9e2af>B256</span>) -&gt; <span style=color:#89dceb>Result</span><span style=color:#89dceb;font-weight:700>&lt;</span>Bytecode, <span style=color:#89dceb>Self</span>::Error<span style=color:#89dceb;font-weight:700>&gt;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6c7086>/// Get storage value of address at index.
</span></span></span><span style=display:flex><span><span style=color:#6c7086></span>    <span style=color:#cba6f7>fn</span> <span style=color:#89b4fa>storage_ref</span>(<span style=color:#89dceb;font-weight:700>&amp;</span><span style=color:#89dceb>self</span>, address: <span style=color:#f9e2af>Address</span>, index: <span style=color:#f9e2af>U256</span>) -&gt; <span style=color:#89dceb>Result</span><span style=color:#89dceb;font-weight:700>&lt;</span>U256, <span style=color:#89dceb>Self</span>::Error<span style=color:#89dceb;font-weight:700>&gt;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6c7086>/// Get block hash by block number.
</span></span></span><span style=display:flex><span><span style=color:#6c7086></span>    <span style=color:#cba6f7>fn</span> <span style=color:#89b4fa>block_hash_ref</span>(<span style=color:#89dceb;font-weight:700>&amp;</span><span style=color:#89dceb>self</span>, number: <span style=color:#f9e2af>U256</span>) -&gt; <span style=color:#89dceb>Result</span><span style=color:#89dceb;font-weight:700>&lt;</span>B256, <span style=color:#89dceb>Self</span>::Error<span style=color:#89dceb;font-weight:700>&gt;</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>In order to minimize duplication of code and the amount of interfaces to support, the <code>WrapDatabaseRef</code> struct provides a way to adapt any implementation of <code>DatabaseRef</code> to fulfill the <code>Database</code> trait. This is particularly useful when you have a read-only implementation of a database that you want to use in a context where a mutable database interface is expected. The wrapper effectively bridges the gap between these two requirements without forcing the underlying database implementation to adopt mutability.</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rs data-lang=rs><span style=display:flex><span><span style=color:#6c7086>/// Wraps a [`DatabaseRef`] to provide a [`Database`] implementation.
</span></span></span><span style=display:flex><span><span style=color:#6c7086></span><span style=color:#cba6f7>pub</span> <span style=color:#cba6f7>struct</span> <span style=color:#f9e2af>WrapDatabaseRef</span><span style=color:#89dceb;font-weight:700>&lt;</span>T: <span style=color:#f9e2af>DatabaseRef</span><span style=color:#89dceb;font-weight:700>&gt;</span>(<span style=color:#cba6f7>pub</span> T);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6c7086>/// Implement the wrapper around [`DatabaseRef`].
</span></span></span><span style=display:flex><span><span style=color:#6c7086></span><span style=color:#cba6f7>impl</span><span style=color:#89dceb;font-weight:700>&lt;</span>F: <span style=color:#f9e2af>DatabaseRef</span><span style=color:#89dceb;font-weight:700>&gt;</span> <span style=color:#89dceb>From</span><span style=color:#89dceb;font-weight:700>&lt;</span>F<span style=color:#89dceb;font-weight:700>&gt;</span> <span style=color:#cba6f7>for</span> WrapDatabaseRef<span style=color:#89dceb;font-weight:700>&lt;</span>F<span style=color:#89dceb;font-weight:700>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>fn</span> <span style=color:#89b4fa>from</span>(f: <span style=color:#f9e2af>F</span>) -&gt; <span style=color:#f9e2af>Self</span> {
</span></span><span style=display:flex><span>        WrapDatabaseRef(f)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6c7086>/// Implement [`Database`] trait in an immutable manner.
</span></span></span><span style=display:flex><span><span style=color:#6c7086></span><span style=color:#cba6f7>impl</span><span style=color:#89dceb;font-weight:700>&lt;</span>T: <span style=color:#f9e2af>DatabaseRef</span><span style=color:#89dceb;font-weight:700>&gt;</span> Database <span style=color:#cba6f7>for</span> WrapDatabaseRef<span style=color:#89dceb;font-weight:700>&lt;</span>T<span style=color:#89dceb;font-weight:700>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>type</span> <span style=color:#f9e2af>Error</span> <span style=color:#89dceb;font-weight:700>=</span> T::Error;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>fn</span> <span style=color:#89b4fa>basic</span>(<span style=color:#89dceb;font-weight:700>&amp;</span><span style=color:#cba6f7>mut</span> <span style=color:#89dceb>self</span>, address: <span style=color:#f9e2af>Address</span>) -&gt; <span style=color:#89dceb>Result</span><span style=color:#89dceb;font-weight:700>&lt;</span><span style=color:#89dceb>Option</span><span style=color:#89dceb;font-weight:700>&lt;</span>AccountInfo<span style=color:#89dceb;font-weight:700>&gt;</span>, <span style=color:#89dceb>Self</span>::Error<span style=color:#89dceb;font-weight:700>&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#89dceb>self</span>.<span style=color:#fab387>0.</span>basic_ref(address)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>fn</span> <span style=color:#89b4fa>code_by_hash</span>(<span style=color:#89dceb;font-weight:700>&amp;</span><span style=color:#cba6f7>mut</span> <span style=color:#89dceb>self</span>, code_hash: <span style=color:#f9e2af>B256</span>) -&gt; <span style=color:#89dceb>Result</span><span style=color:#89dceb;font-weight:700>&lt;</span>Bytecode, <span style=color:#89dceb>Self</span>::Error<span style=color:#89dceb;font-weight:700>&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#89dceb>self</span>.<span style=color:#fab387>0.</span>code_by_hash_ref(code_hash)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>fn</span> <span style=color:#89b4fa>storage</span>(<span style=color:#89dceb;font-weight:700>&amp;</span><span style=color:#cba6f7>mut</span> <span style=color:#89dceb>self</span>, address: <span style=color:#f9e2af>Address</span>, index: <span style=color:#f9e2af>U256</span>) -&gt; <span style=color:#89dceb>Result</span><span style=color:#89dceb;font-weight:700>&lt;</span>U256, <span style=color:#89dceb>Self</span>::Error<span style=color:#89dceb;font-weight:700>&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#89dceb>self</span>.<span style=color:#fab387>0.</span>storage_ref(address, index)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>fn</span> <span style=color:#89b4fa>block_hash</span>(<span style=color:#89dceb;font-weight:700>&amp;</span><span style=color:#cba6f7>mut</span> <span style=color:#89dceb>self</span>, number: <span style=color:#f9e2af>U256</span>) -&gt; <span style=color:#89dceb>Result</span><span style=color:#89dceb;font-weight:700>&lt;</span>B256, <span style=color:#89dceb>Self</span>::Error<span style=color:#89dceb;font-weight:700>&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#89dceb>self</span>.<span style=color:#fab387>0.</span>block_hash_ref(number)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=transient-storage>Transient Storage<a hidden class=anchor aria-hidden=true href=#transient-storage>#</a></h2><p>As per <a href=https://eips.ethereum.org/EIPS/eip-1153>EIP-1153</a>, after the Cancun hard fork, the EVM will also implement <strong>transient storage</strong>. A new type of data storage mechanism that is identical to regular storage, but which is <strong>discarded after every transaction</strong> (only persists within a transaction). Its main application being cheaper reentrancy locks.</p><p>This difference between the two, means that the <code>TransientStorage</code> definition can be simplified. Rather than relying on a nested hashmap <code>State > Account [Storage] > Slot</code>, the key of the <code>TransientStorage</code> hashmap is a tuple composed by the account address, and the storage slot.</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rs data-lang=rs><span style=display:flex><span><span style=color:#6c7086>/// Structure used for EIP-1153 transient storage.
</span></span></span><span style=display:flex><span><span style=color:#6c7086></span><span style=color:#cba6f7>pub</span> <span style=color:#cba6f7>type</span> <span style=color:#f9e2af>TransientStorage</span> <span style=color:#89dceb;font-weight:700>=</span> HashMap<span style=color:#89dceb;font-weight:700>&lt;</span>(Address, U256), U256<span style=color:#89dceb;font-weight:700>&gt;</span>;
</span></span></code></pre></div><h2 id=gas>Gas<a hidden class=anchor aria-hidden=true href=#gas>#</a></h2><p>As for computation costs, the EVM employs a mechanism pricing mechanism called gas. in order to execute a transaction, users must pay a gas fee to compensate for the computational resources they spend. By doing so, we can ensure that the network is not vulnerable to spam and cannot get stuck in infinite computational loops. The gas associated with each operation is different, and must be paid regardless of the outcome of the transaction, even if it reverts.</p><p>Apart from the computation costs, extra gas is charged to form the payment for a subordinate message call or contract creation (payment is embedded in the <code>CREATE</code>, <code>CREATE2</code>, <code>CALL</code> and <code>CALLCODE</code> opcodes).</p><p>On top of that, extra gas is also charged when expanding the memory. Since memory is word-addressable, its expansion happens in 32-byte bounds. Note that expansion will happen regardless of the nature of the memory operation (either read or write).</p><p>Finally, to help address the state growth problem, gas refunds are given when storage slots are cleared.</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rs data-lang=rs><span style=display:flex><span><span style=color:#6c7086>/// Represents the state of gas during execution.
</span></span></span><span style=display:flex><span><span style=color:#6c7086></span><span style=color:#cba6f7>pub</span> <span style=color:#cba6f7>struct</span> <span style=color:#f9e2af>Gas</span> {
</span></span><span style=display:flex><span>    <span style=color:#6c7086>/// The initial gas limit.
</span></span></span><span style=display:flex><span><span style=color:#6c7086></span>    limit: <span style=color:#f38ba8>u64</span>,
</span></span><span style=display:flex><span>    <span style=color:#6c7086>/// The total used gas.
</span></span></span><span style=display:flex><span><span style=color:#6c7086></span>    all_used_gas: <span style=color:#f38ba8>u64</span>,
</span></span><span style=display:flex><span>    <span style=color:#6c7086>/// Used gas without memory expansion.
</span></span></span><span style=display:flex><span><span style=color:#6c7086></span>    used: <span style=color:#f38ba8>u64</span>,
</span></span><span style=display:flex><span>    <span style=color:#6c7086>/// Used gas for memory expansion.
</span></span></span><span style=display:flex><span><span style=color:#6c7086></span>    memory: <span style=color:#f38ba8>u64</span>,
</span></span><span style=display:flex><span>    <span style=color:#6c7086>/// Refunded gas. This is used only at the end of execution.
</span></span></span><span style=display:flex><span><span style=color:#6c7086></span>    refunded: <span style=color:#f38ba8>i64</span>,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>With the introduction of <a href=https://eips.ethereum.org/EIPS/eip-1559>EIP-1559</a> after the London hard fork, the fees paid by users are split between a base fee -common for all the txs in a block- and a user-defined priority fee. This change lowered the volatility in gas prices, and gave user better predictibility.</p><p>To learn more about gas fees (structure, limits, pricing, etc.) check the following <a href=https://ethereum.org/developers/docs/gas>article</a>.</p><h2 id=execution-environment>Execution Environment<a hidden class=anchor aria-hidden=true href=#execution-environment>#</a></h2><p>Environmental data necessary for the execution of the state transition. This section is quite self-explanatory thanks to the verbose (great) comments of the <code>revm</code> contributors. Overall, it shouldn&rsquo;t introduce new topics to people who are already familiar with the Ethereum network.</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rs data-lang=rs><span style=display:flex><span><span style=color:#6c7086>/// EVM environment configuration.
</span></span></span><span style=display:flex><span><span style=color:#6c7086></span><span style=color:#cba6f7>pub</span> <span style=color:#cba6f7>struct</span> <span style=color:#f9e2af>Env</span> {
</span></span><span style=display:flex><span>    <span style=color:#6c7086>/// Configuration of the block the transaction is in.
</span></span></span><span style=display:flex><span><span style=color:#6c7086></span>    <span style=color:#cba6f7>pub</span> block: <span style=color:#f9e2af>BlockEnv</span>,
</span></span><span style=display:flex><span>    <span style=color:#6c7086>/// Configuration of the transaction that is being executed.
</span></span></span><span style=display:flex><span><span style=color:#6c7086></span>    <span style=color:#cba6f7>pub</span> tx: <span style=color:#f9e2af>TxEnv</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6c7086>/// The block environment.
</span></span></span><span style=display:flex><span><span style=color:#6c7086></span><span style=color:#cba6f7>pub</span> <span style=color:#cba6f7>struct</span> <span style=color:#f9e2af>BlockEnv</span> {
</span></span><span style=display:flex><span>    <span style=color:#6c7086>/// The number of ancestor blocks of this block (block height).
</span></span></span><span style=display:flex><span><span style=color:#6c7086></span>    <span style=color:#cba6f7>pub</span> number: <span style=color:#f9e2af>U256</span>,
</span></span><span style=display:flex><span>    <span style=color:#6c7086>/// Coinbase or miner or address that created and signed the block.
</span></span></span><span style=display:flex><span><span style=color:#6c7086></span>    <span style=color:#6c7086>/// This is the receiver address of all the gas spent in the block.
</span></span></span><span style=display:flex><span><span style=color:#6c7086></span>    <span style=color:#cba6f7>pub</span> coinbase: <span style=color:#f9e2af>Address</span>,
</span></span><span style=display:flex><span>    <span style=color:#6c7086>/// The timestamp of the block in seconds since the UNIX epoch.
</span></span></span><span style=display:flex><span><span style=color:#6c7086></span>    <span style=color:#cba6f7>pub</span> timestamp: <span style=color:#f9e2af>U256</span>,
</span></span><span style=display:flex><span>    <span style=color:#6c7086>/// The gas limit of the block.
</span></span></span><span style=display:flex><span><span style=color:#6c7086></span>    <span style=color:#cba6f7>pub</span> gas_limit: <span style=color:#f9e2af>U256</span>,
</span></span><span style=display:flex><span>    <span style=color:#6c7086>/// The base fee per gas, added in the London upgrade with [EIP-1559].
</span></span></span><span style=display:flex><span><span style=color:#6c7086></span>    <span style=color:#cba6f7>pub</span> basefee: <span style=color:#f9e2af>U256</span>,
</span></span><span style=display:flex><span>    <span style=color:#6c7086>/// The difficulty of the block.
</span></span></span><span style=display:flex><span><span style=color:#6c7086></span>    <span style=color:#6c7086>/// Unused after Paris (AKA the merge) upgrade, and replaced by `prevrandao`.
</span></span></span><span style=display:flex><span><span style=color:#6c7086></span>    <span style=color:#cba6f7>pub</span> difficulty: <span style=color:#f9e2af>U256</span>,
</span></span><span style=display:flex><span>    <span style=color:#6c7086>/// The output of the randomness beacon provided by the beacon chain.
</span></span></span><span style=display:flex><span><span style=color:#6c7086></span>    <span style=color:#6c7086>/// Replaces `difficulty` after Paris (AKA the merge) upgrade with [EIP-4399].
</span></span></span><span style=display:flex><span><span style=color:#6c7086></span>    <span style=color:#cba6f7>pub</span> prevrandao: <span style=color:#89dceb>Option</span><span style=color:#89dceb;font-weight:700>&lt;</span>B256<span style=color:#89dceb;font-weight:700>&gt;</span>,
</span></span><span style=display:flex><span>    <span style=color:#6c7086>/// Excess blob gas and blob gasprice.
</span></span></span><span style=display:flex><span><span style=color:#6c7086></span>    <span style=color:#6c7086>/// Incorporated as part of the Cancun upgrade via [EIP-4844].
</span></span></span><span style=display:flex><span><span style=color:#6c7086></span>    <span style=color:#cba6f7>pub</span> blob_excess_gas_and_price: <span style=color:#89dceb>Option</span><span style=color:#89dceb;font-weight:700>&lt;</span>BlobExcessGasAndPrice<span style=color:#89dceb;font-weight:700>&gt;</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6c7086>/// The transaction environment.
</span></span></span><span style=display:flex><span><span style=color:#6c7086></span><span style=color:#cba6f7>pub</span> <span style=color:#cba6f7>struct</span> <span style=color:#f9e2af>TxEnv</span> {
</span></span><span style=display:flex><span>    <span style=color:#6c7086>/// Caller aka Author aka transaction signer.
</span></span></span><span style=display:flex><span><span style=color:#6c7086></span>    <span style=color:#cba6f7>pub</span> caller: <span style=color:#f9e2af>Address</span>,
</span></span><span style=display:flex><span>    <span style=color:#6c7086>/// The gas limit of the transaction.
</span></span></span><span style=display:flex><span><span style=color:#6c7086></span>    <span style=color:#cba6f7>pub</span> gas_limit: <span style=color:#f38ba8>u64</span>,
</span></span><span style=display:flex><span>    <span style=color:#6c7086>/// The gas price of the transaction.
</span></span></span><span style=display:flex><span><span style=color:#6c7086></span>    <span style=color:#cba6f7>pub</span> gas_price: <span style=color:#f9e2af>U256</span>,
</span></span><span style=display:flex><span>    <span style=color:#6c7086>/// The destination of the transaction.
</span></span></span><span style=display:flex><span><span style=color:#6c7086></span>    <span style=color:#cba6f7>pub</span> transact_to: <span style=color:#f9e2af>TransactTo</span>,
</span></span><span style=display:flex><span>    <span style=color:#6c7086>/// The value sent to `transact_to`.
</span></span></span><span style=display:flex><span><span style=color:#6c7086></span>    <span style=color:#cba6f7>pub</span> value: <span style=color:#f9e2af>U256</span>,
</span></span><span style=display:flex><span>    <span style=color:#6c7086>/// The calldata of the transaction.
</span></span></span><span style=display:flex><span><span style=color:#6c7086></span>    <span style=color:#cba6f7>pub</span> data: <span style=color:#f9e2af>Bytes</span>,
</span></span><span style=display:flex><span>    <span style=color:#6c7086>/// The nonce of the transaction. If set to `None`, no checks are performed.
</span></span></span><span style=display:flex><span><span style=color:#6c7086></span>    <span style=color:#cba6f7>pub</span> nonce: <span style=color:#89dceb>Option</span><span style=color:#89dceb;font-weight:700>&lt;</span><span style=color:#f38ba8>u64</span><span style=color:#89dceb;font-weight:700>&gt;</span>,
</span></span><span style=display:flex><span>    <span style=color:#6c7086>/// The chain ID of the tx. If set to `None`, no checks are performed.
</span></span></span><span style=display:flex><span><span style=color:#6c7086></span>    <span style=color:#6c7086>/// Incorporated as part of the Spurious Dragon upgrade via [EIP-155].
</span></span></span><span style=display:flex><span><span style=color:#6c7086></span>    <span style=color:#cba6f7>pub</span> chain_id: <span style=color:#89dceb>Option</span><span style=color:#89dceb;font-weight:700>&lt;</span><span style=color:#f38ba8>u64</span><span style=color:#89dceb;font-weight:700>&gt;</span>,
</span></span><span style=display:flex><span>    <span style=color:#6c7086>/// A list of addresses and storage keys that the transaction plans to access.
</span></span></span><span style=display:flex><span><span style=color:#6c7086></span>    <span style=color:#6c7086>/// Added in [EIP-2930].
</span></span></span><span style=display:flex><span><span style=color:#6c7086></span>    <span style=color:#cba6f7>pub</span> access_list: <span style=color:#89dceb>Vec</span><span style=color:#89dceb;font-weight:700>&lt;</span>(Address, <span style=color:#89dceb>Vec</span><span style=color:#89dceb;font-weight:700>&lt;</span>U256<span style=color:#89dceb;font-weight:700>&gt;</span>)<span style=color:#89dceb;font-weight:700>&gt;</span>,
</span></span><span style=display:flex><span>    <span style=color:#6c7086>/// The priority fee per gas.
</span></span></span><span style=display:flex><span><span style=color:#6c7086></span>    <span style=color:#6c7086>/// Incorporated as part of the London upgrade via [EIP-1559].
</span></span></span><span style=display:flex><span><span style=color:#6c7086></span>    <span style=color:#cba6f7>pub</span> gas_priority_fee: <span style=color:#89dceb>Option</span><span style=color:#89dceb;font-weight:700>&lt;</span>U256<span style=color:#89dceb;font-weight:700>&gt;</span>,
</span></span><span style=display:flex><span>    <span style=color:#6c7086>/// The list of blob versioned hashes. Per EIP there should be at least
</span></span></span><span style=display:flex><span><span style=color:#6c7086></span>    <span style=color:#6c7086>/// one blob present if [`Self::max_fee_per_blob_gas`] is `Some`.
</span></span></span><span style=display:flex><span><span style=color:#6c7086></span>    <span style=color:#6c7086>/// Incorporated as part of the Cancun upgrade via [EIP-4844].
</span></span></span><span style=display:flex><span><span style=color:#6c7086></span>    <span style=color:#cba6f7>pub</span> blob_hashes: <span style=color:#89dceb>Vec</span><span style=color:#89dceb;font-weight:700>&lt;</span>B256<span style=color:#89dceb;font-weight:700>&gt;</span>,
</span></span><span style=display:flex><span>    <span style=color:#6c7086>/// The max fee per blob gas.
</span></span></span><span style=display:flex><span><span style=color:#6c7086></span>    <span style=color:#6c7086>/// Incorporated as part of the Cancun upgrade via [EIP-4844].
</span></span></span><span style=display:flex><span><span style=color:#6c7086></span>    <span style=color:#cba6f7>pub</span> max_fee_per_blob_gas: <span style=color:#89dceb>Option</span><span style=color:#89dceb;font-weight:700>&lt;</span>U256<span style=color:#89dceb;font-weight:700>&gt;</span>,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><em>Note: The blob-related attributes refer to a new gas pricing mechanism for blob-carrying transactions. These are similar to regular transactions but include an additional set of data called blob (Binary Large Object). The main goal of this change is to allow roll-ups to still post their commitments on-chain. However, instead of doing it on the execution layer via calldata, they can do it on the beacon chain (consensus layer), where the blobs will be pruned in a couple of weeks. This pruning timeline gives enough time for provers to check the data commitments of the rollup and challenge them if necessary. For further detail check the <a href=https://www.eip4844.com/>proto-danksharding website</a>.</em></p><p><code>TransactTo</code> is an enum that specifies the target of the transaction, which can be either a call or the creation of a new contract. Note that new contracts can be deterministically created by using a user-defined salt.</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rs data-lang=rs><span style=display:flex><span><span style=color:#cba6f7>pub</span> <span style=color:#cba6f7>enum</span> <span style=color:#f9e2af>TransactTo</span> {
</span></span><span style=display:flex><span>    <span style=color:#6c7086>/// Simple call to an address.
</span></span></span><span style=display:flex><span><span style=color:#6c7086></span>    Call(Address),
</span></span><span style=display:flex><span>    <span style=color:#6c7086>/// Contract creation.
</span></span></span><span style=display:flex><span><span style=color:#6c7086></span>    Create(CreateScheme),
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#cba6f7>pub</span> <span style=color:#cba6f7>enum</span> <span style=color:#f9e2af>CreateScheme</span> {
</span></span><span style=display:flex><span>    <span style=color:#6c7086>/// Legacy create scheme of `CREATE`.
</span></span></span><span style=display:flex><span><span style=color:#6c7086></span>    Create,
</span></span><span style=display:flex><span>    <span style=color:#6c7086>/// Create scheme of `CREATE2`.
</span></span></span><span style=display:flex><span><span style=color:#6c7086></span>    Create2 { salt: <span style=color:#f9e2af>U256</span> },
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h1 id=evm-execution>EVM Execution<a hidden class=anchor aria-hidden=true href=#evm-execution>#</a></h1><p>The EVM&rsquo;s deterministic nature ensures that Ethereum operates as a network with a state transition function. Given a current state and a series of transactions, it deterministically transitions to a new valid state.</p><p>Transactions can only be triggered by externally-owned accounts (EOAs), and they either initiate message calls or deploy new contracts. In both cases, the stack is loaded with opcodes and data (from transaction calldata, memory, or storage) to execute instructions and transition to a new state.</p><figure class=align-center><img loading=lazy src=/blog/images/revm/execution-diagram.png#center alt="EVM execution model showcasing how the different components interact with each other."><figcaption><p><em>EVM execution model showcasing how the different components interact with each other.</em></p></figcaption></figure><h2 id=the-interpreter>The Interpreter<a hidden class=anchor aria-hidden=true href=#the-interpreter>#</a></h2><p>As seen in the previous diagram, the interpreter is the core engine of the EVM. It is in charge of running the execution loop that processes and executes each of the instructions stored in the bytecode.</p><p>Based on the above definition, we could label: program counter, stack, memory, and gas, as direct (internal) dependencies of the interpreter. Whereas storage, and the execution context, are somehow agnostic to it (external). Because of that, it seems reasonable to separate both implementations under different crates.</p><h2 id=the-host>The Host<a hidden class=anchor aria-hidden=true href=#the-host>#</a></h2><p>This explicit separation, surfaces the need for an interface that facilitates the interaction of the EVM interpreter with its environment, encompassing essential operations such as accessing block, transaction or account data, accessing storage, or logging data. To fulfill this need, the <code>Host</code> trait has been created.</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rs data-lang=rs><span style=display:flex><span><span style=color:#6c7086>/// EVM context host.
</span></span></span><span style=display:flex><span><span style=color:#6c7086></span><span style=color:#cba6f7>pub</span> <span style=color:#cba6f7>trait</span> Host {
</span></span><span style=display:flex><span>    <span style=color:#6c7086>/// Returns a mutable reference to the environment.
</span></span></span><span style=display:flex><span><span style=color:#6c7086></span>    <span style=color:#cba6f7>fn</span> <span style=color:#89b4fa>env</span>(<span style=color:#89dceb;font-weight:700>&amp;</span><span style=color:#cba6f7>mut</span> <span style=color:#89dceb>self</span>) -&gt; <span style=color:#cba6f7>&amp;</span><span style=color:#f9e2af>mut</span> Env;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6c7086>/// Loads an account. Returns (is_cold, is_new_account)
</span></span></span><span style=display:flex><span><span style=color:#6c7086></span>    <span style=color:#cba6f7>fn</span> <span style=color:#89b4fa>load_account</span>(<span style=color:#89dceb;font-weight:700>&amp;</span><span style=color:#cba6f7>mut</span> <span style=color:#89dceb>self</span>, address: <span style=color:#f9e2af>Address</span>) -&gt; <span style=color:#89dceb>Option</span><span style=color:#89dceb;font-weight:700>&lt;</span>(<span style=color:#f38ba8>bool</span>, <span style=color:#f38ba8>bool</span>)<span style=color:#89dceb;font-weight:700>&gt;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6c7086>/// Get the block hash of the given block `number`.
</span></span></span><span style=display:flex><span><span style=color:#6c7086></span>    <span style=color:#cba6f7>fn</span> <span style=color:#89b4fa>block_hash</span>(<span style=color:#89dceb;font-weight:700>&amp;</span><span style=color:#cba6f7>mut</span> <span style=color:#89dceb>self</span>, number: <span style=color:#f9e2af>U256</span>) -&gt; <span style=color:#89dceb>Option</span><span style=color:#89dceb;font-weight:700>&lt;</span>B256<span style=color:#89dceb;font-weight:700>&gt;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6c7086>/// Get balance of `address` and if the account is cold.
</span></span></span><span style=display:flex><span><span style=color:#6c7086></span>    <span style=color:#cba6f7>fn</span> <span style=color:#89b4fa>balance</span>(<span style=color:#89dceb;font-weight:700>&amp;</span><span style=color:#cba6f7>mut</span> <span style=color:#89dceb>self</span>, address: <span style=color:#f9e2af>Address</span>) -&gt; <span style=color:#89dceb>Option</span><span style=color:#89dceb;font-weight:700>&lt;</span>(U256, <span style=color:#f38ba8>bool</span>)<span style=color:#89dceb;font-weight:700>&gt;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6c7086>/// Get code of `address` and if the account is cold.
</span></span></span><span style=display:flex><span><span style=color:#6c7086></span>    <span style=color:#cba6f7>fn</span> <span style=color:#89b4fa>code</span>(<span style=color:#89dceb;font-weight:700>&amp;</span><span style=color:#cba6f7>mut</span> <span style=color:#89dceb>self</span>, address: <span style=color:#f9e2af>Address</span>) -&gt; <span style=color:#89dceb>Option</span><span style=color:#89dceb;font-weight:700>&lt;</span>(Bytecode, <span style=color:#f38ba8>bool</span>)<span style=color:#89dceb;font-weight:700>&gt;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6c7086>/// Get code hash of `address` and if the account is cold.
</span></span></span><span style=display:flex><span><span style=color:#6c7086></span>    <span style=color:#cba6f7>fn</span> <span style=color:#89b4fa>code_hash</span>(<span style=color:#89dceb;font-weight:700>&amp;</span><span style=color:#cba6f7>mut</span> <span style=color:#89dceb>self</span>, address: <span style=color:#f9e2af>Address</span>) -&gt; <span style=color:#89dceb>Option</span><span style=color:#89dceb;font-weight:700>&lt;</span>(B256, <span style=color:#f38ba8>bool</span>)<span style=color:#89dceb;font-weight:700>&gt;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6c7086>/// Get storage value of `address` at `index` and if the account is cold.
</span></span></span><span style=display:flex><span><span style=color:#6c7086></span>    <span style=color:#cba6f7>fn</span> <span style=color:#89b4fa>sload</span>(<span style=color:#89dceb;font-weight:700>&amp;</span><span style=color:#cba6f7>mut</span> <span style=color:#89dceb>self</span>, address: <span style=color:#f9e2af>Address</span>, index: <span style=color:#f9e2af>U256</span>) -&gt; <span style=color:#89dceb>Option</span><span style=color:#89dceb;font-weight:700>&lt;</span>(U256, <span style=color:#f38ba8>bool</span>)<span style=color:#89dceb;font-weight:700>&gt;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6c7086>/// Set storage value of account address at index.
</span></span></span><span style=display:flex><span><span style=color:#6c7086></span>    <span style=color:#6c7086>/// Returns (original, present, new, is_cold).
</span></span></span><span style=display:flex><span><span style=color:#6c7086></span>    <span style=color:#cba6f7>fn</span> <span style=color:#89b4fa>sstore</span>(
</span></span><span style=display:flex><span>        <span style=color:#89dceb;font-weight:700>&amp;</span><span style=color:#cba6f7>mut</span> <span style=color:#89dceb>self</span>,
</span></span><span style=display:flex><span>        address: <span style=color:#f9e2af>Address</span>,
</span></span><span style=display:flex><span>        index: <span style=color:#f9e2af>U256</span>,
</span></span><span style=display:flex><span>        value: <span style=color:#f9e2af>U256</span>,
</span></span><span style=display:flex><span>    ) -&gt; <span style=color:#89dceb>Option</span><span style=color:#89dceb;font-weight:700>&lt;</span>(U256, U256, U256, <span style=color:#f38ba8>bool</span>)<span style=color:#89dceb;font-weight:700>&gt;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6c7086>/// Get the transient storage value of `address` at `index`.
</span></span></span><span style=display:flex><span><span style=color:#6c7086></span>    <span style=color:#cba6f7>fn</span> <span style=color:#89b4fa>tload</span>(<span style=color:#89dceb;font-weight:700>&amp;</span><span style=color:#cba6f7>mut</span> <span style=color:#89dceb>self</span>, address: <span style=color:#f9e2af>Address</span>, index: <span style=color:#f9e2af>U256</span>) -&gt; <span style=color:#f9e2af>U256</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6c7086>/// Set the transient storage value of `address` at `index`.
</span></span></span><span style=display:flex><span><span style=color:#6c7086></span>    <span style=color:#cba6f7>fn</span> <span style=color:#89b4fa>tstore</span>(<span style=color:#89dceb;font-weight:700>&amp;</span><span style=color:#cba6f7>mut</span> <span style=color:#89dceb>self</span>, address: <span style=color:#f9e2af>Address</span>, index: <span style=color:#f9e2af>U256</span>, value: <span style=color:#f9e2af>U256</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6c7086>/// Emit a log owned by `address` with given `LogData`.
</span></span></span><span style=display:flex><span><span style=color:#6c7086></span>    <span style=color:#cba6f7>fn</span> <span style=color:#89b4fa>log</span>(<span style=color:#89dceb;font-weight:700>&amp;</span><span style=color:#cba6f7>mut</span> <span style=color:#89dceb>self</span>, log: <span style=color:#f9e2af>Log</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6c7086>/// Mark `address` to be deleted, with funds transferred to `target`.
</span></span></span><span style=display:flex><span><span style=color:#6c7086></span>    <span style=color:#cba6f7>fn</span> <span style=color:#89b4fa>selfdestruct</span>(
</span></span><span style=display:flex><span>        <span style=color:#89dceb;font-weight:700>&amp;</span><span style=color:#cba6f7>mut</span> <span style=color:#89dceb>self</span>,
</span></span><span style=display:flex><span>        address: <span style=color:#f9e2af>Address</span>,
</span></span><span style=display:flex><span>        target: <span style=color:#f9e2af>Address</span>
</span></span><span style=display:flex><span>    ) -&gt; <span style=color:#89dceb>Option</span><span style=color:#89dceb;font-weight:700>&lt;</span>SelfDestructResult<span style=color:#89dceb;font-weight:700>&gt;</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This abstraction allows the interpreter to interact with any host environment -as long as the trait is implemented-, thereby enhancing modularity and interoperability. Different implementations can be used to simulate different environments when connecting to different EVM-compatible networks.</p><h2 id=a-closing-example>A closing example<a hidden class=anchor aria-hidden=true href=#a-closing-example>#</a></h2><p>In the next article of the series, we will review in detail how each opcode works. On the meantime, in order to further exemplify how the execution of an EVM transaction works, the following snippet showcases a representation of the bytecode that we initially disassembled: <code>0x6000356020350160005260206000f3</code>.</p><pre tabindex=0><code>PC   BYTECODE   MNEMONIC       STACK          ACTION
0    60 00      PUSH1 0x00     [0x00]         Push 0 to the stack.
2    35         CALLDATALOAD   [num1]         Load first 32 bytes on the stack.
3    60 20      PUSH1 0x20     [0x20, num1]   Push 32 to the stack.
5    35         CALLDATALOAD   [num2, num1]   Load second 32 bytes on the stack.
6    01         ADD            [n2+n1]        Take 2 stack inputs and add them.
7    60 00      PUSH1 0x00     [0x0, n2+n1]   Push 0 to the stack.
9    52         MSTORE         []             Store n2+n1 with offset 0 in memory.
10   60 20      PUSH1 0x20     [0x20]         Push 32 to the stack.
12   60 00      PUSH1 0x00     [0x00, 0x20]   Push 0 to the stack.
14   f3         RETURN         []             Return the first 32 bytes of memory.
</code></pre><p>Given 64 bytes of calldata (2 words), and by executing our small bytecode with the EVM interpreter, we loaded them into the stack, added them, stored them in memory, and finally returned the output. Quite an achievement!</p><hr><p>That&rsquo;s a wrap! In this article, we&rsquo;ve discussed the basics of the EVM, its high-level mechanics, and its core building blocks. Armed with this knowledge, we are better prepared to understand how these components interact with each other.</p><p>Moving forward, in the next article, we will delve into the EVM interpreter, exploring its role and functionality in greater detail. Specifically, we will focus on the instruction set that powers the EVM.</p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=next href=https://0xrusowsky.github.io/blog/articles/ethereum-made-in-rust/><span class=title>Prev »</span><br><span>Ethereum, but made in Rust</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://0xrusowsky.github.io/blog/>0xrusowsky</a></span>
<span>      Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>