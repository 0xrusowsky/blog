<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Ethereum Virtual Machine (in Rust) - Part 2 | 0xrusowsky</title>
<meta name=keywords content><meta name=description content="In this second article of the revm series, we will dive deeper into the EVM interpreter. We will understand how it works, especially focusing on the different opcodes."><meta name=author content="0xrusowsky"><link rel=canonical href=https://0xrusowsky.github.io/blog/articles/revm-pt2/><link crossorigin=anonymous href=/blog/assets/css/stylesheet.864d7d0a8a5d5fd719e1743dfeef7df4c4862d0a62b239bfbd9186dec2feffcf.css integrity="sha256-hk19CopdX9cZ4XQ9/u999MSGLQpisjm/vZGG3sL+/88=" rel="preload stylesheet" as=style><link rel=icon href=https://0xrusowsky.github.io/blog/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://0xrusowsky.github.io/blog/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://0xrusowsky.github.io/blog/favicon-32x32.png><link rel=apple-touch-icon href=https://0xrusowsky.github.io/blog/apple-touch-icon.png><link rel=mask-icon href=https://0xrusowsky.github.io/blog/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Ethereum Virtual Machine (in Rust) - Part 2"><meta property="og:description" content="In this second article of the revm series, we will dive deeper into the EVM interpreter. We will understand how it works, especially focusing on the different opcodes."><meta property="og:type" content="article"><meta property="og:url" content="https://0xrusowsky.github.io/blog/articles/revm-pt2/"><meta property="article:section" content="articles"><meta property="article:published_time" content="2024-03-04T16:00:00+00:00"><meta property="article:modified_time" content="2024-03-04T16:00:00+00:00"><meta property="og:site_name" content="0xrusowsky"><meta name=twitter:card content="summary"><meta name=twitter:title content="Ethereum Virtual Machine (in Rust) - Part 2"><meta name=twitter:description content="In this second article of the revm series, we will dive deeper into the EVM interpreter. We will understand how it works, especially focusing on the different opcodes."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Articles","item":"https://0xrusowsky.github.io/blog/articles/"},{"@type":"ListItem","position":2,"name":"Ethereum Virtual Machine (in Rust) - Part 2","item":"https://0xrusowsky.github.io/blog/articles/revm-pt2/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Ethereum Virtual Machine (in Rust) - Part 2","name":"Ethereum Virtual Machine (in Rust) - Part 2","description":"In this second article of the revm series, we will dive deeper into the EVM interpreter. We will understand how it works, especially focusing on the different opcodes.","keywords":[],"articleBody":"Interpreter As uncovered in the previous article —which I highly recommend checking out if you haven’t yet—, the interpreter is the core engine of the EVM. It is in charge of running the execution loop that processes and executes each of the instructions stored in the bytecode. Additionally, besides the computation and returning the results of the execution, the interpreter also needs to keep track of the gas consumption.\nTo fulfill its tasks, the interpreter will use its attributes (contract bytecode, stack, memory, etc.) and also interact with the EVM host.\nRepresentation of revm’s interpreter.\nThe following definition of the Interpreter struct gives it control over all the attributes described in the diagram above. Additionally, the InstructionResult enum, and the Contract struct, are also defined.\npub struct Interpreter { // Contract information and invoking data pub contract: Box\u003cContract\u003e, // The current instruction pointer. pub instruction_pointer: *const u8, // Execution control flag. If not set to `Continue`, the execution will stop. pub instruction_result: InstructionResult, // The gas state. pub gas: Gas, // Memory. // Only set while running the loop. Otherwise taken and emptied. pub memory: Memory, // Stack. pub stack: Stack // When the execution finished, contains the output bytes of the contract. pub return_data: Bytes, } The InstructionResult enum categorizes the outcomes of instruction executions, providing granularity and enabling the interpreter to handle success, reverts, and errors elegantly. These components, among others, ensure the interpreter’s smooth operation and robust error handling.\npub enum InstructionResult { // Success #[default] Continue = 0x00, Stop, Return, // Revert Revert = 0x10, CallTooDeep, OutOfFunds, // Errors OutOfGas = 0x50, OpcodeNotFound, StackUnderflow, StackOverflow, // ... } impl InstructionResult { // Returns whether the result is a success. pub const fn is_ok(self) -\u003e bool { matches!(self, crate::return_ok!()) } // Returns whether the result is a revert. pub const fn is_revert(self) -\u003e bool { matches!(self, crate::return_revert!()) } // Returns whether the result is an error. pub const fn is_error(self) -\u003e bool { matches!(self, return_error!()) } } The usage of macros is just for maintainability purposes, as they simply return the enum variants that match the outcome of the match statement. When new reason codes are added to the EVM, code maintainers simply need to add a new variant to the macro.\nmacro_rules! return_ok { () =\u003e { InstructionResult::Continue | InstructionResult::Stop | InstructionResult::Return }; } Contracts The Contract struct holds all data related to the target bytecode to be executed, as well as the invoking data in its function call.\n// EVM contract information. pub struct Contract { // Contracts data pub input: Bytes, // Contract code, size of original code, and jump table. // Note that current code is extended with push padding and STOP at the end. pub bytecode: BytecodeLocked, // Bytecode hash. pub hash: B256, // Contract address pub address: Address, // Caller of the EVM. pub caller: Address, // Value send to contract. pub value: U256, } Before exploring BytecodeLocked, let’s examine the initialization functions for the Contract struct, including the standard fn new() method and the convenient fn new_env() to create a new contract instance from the current EVM environment.\nimpl Contract { // Instantiates a new contract by analyzing the given bytecode. pub fn new( input: Bytes, bytecode: Bytecode, hash: B256, address: Address, caller: Address, value: U256, ) -\u003e Self { let bytecode = to_analysed(bytecode).try_into().expect(\"analysed\"); Self {input, bytecode, hash, address, caller, value} } // Creates a new contract from the given [`Env`]. pub fn new_env(env: \u0026Env, bytecode: Bytecode, hash: B256) -\u003e Self { let address = match env.tx.transact_to { TransactTo::Call(caller) =\u003e caller, TransactTo::Create(..) =\u003e Address::ZERO, }; let data = env.tx.data.clone(); Self::new(data, bytecode, hash, address, env.tx.caller, env.tx.value) } } Bytecode: type definition and analysis When we explored the building blocks of the EVM, we simply mentioned that the world state holds all the basic account information, including its bytecode. Nevertheless, there is more to it.\nLater on, we will analyze in depth how do push and jump-related opcodes work, but for the time being you should know that:\nPUSH opcodes are characterized for consuming bytes directly from the contract bytecode, to use as inputs for the interpreter. JUMP, and JUMPI opcodes are a control-flow-type of opcodes that require a pre-defined valid jump destination JUMPDEST to be informed within the bytecode. Given the complex interplay between push and jump-related opcodes, verifying jump destinations during execution becomes non-trivial and inefficient. This complexity arises due to the need to differentiate between genuine jump destinations those potentially disguised as inputs from PUSH opcodes. By performing a pre-execution analysis of the bytecode to identify all valid jump destinations, a JumpMap can be created beforehand. This proactive approach streamlines execution and eliminates the inefficiency of runtime checks.\n// A vector where each element represents a byte from the contract code. // Each element is marked as either an invalid (0) or valid (1) jump destination. pub struct JumpMap(pub Arc\u003cBitVec\u003cu8\u003e\u003e); impl JumpMap { // Check if `pc` is a valid jump destination. pub fn is_valid(\u0026self, pc: usize) -\u003e bool { pc \u003c self.0.len() \u0026\u0026 self.0[pc] } } // Analyze bytecode to build a jump map. fn analyze(code: \u0026[u8]) -\u003e JumpMap { let mut jumps: BitVec\u003cu8\u003e = bitvec![u8, Lsb0; 0; code.len()]; let range = code.as_ptr_range(); let start = range.start; let mut iter = start; let end = range.end; while iter \u003c end { let opcode = unsafe { *iter }; if opcode::JUMPDEST == opcode { // SAFETY: jumps are max length of the code unsafe { jumps.set_unchecked(iter.offset_from(start) as usize, true) } iter = unsafe { iter.offset(1) }; } else { let push_offset = opcode.wrapping_sub(opcode::PUSH1); if push_offset \u003c 32 { // SAFETY: iterator access range is checked in the while loop iter = unsafe { iter.offset((push_offset + 2) as isize) }; } else { // SAFETY: iterator access range is checked in the while loop iter = unsafe { iter.offset(1) }; } } } JumpMap(Arc::new(jumps)) } As analyzing the bytecode requires some computation, for the sake of performance, it is useful to define a Bytecode struct with different BytecodeState. By defining 3 different states, a more granular and efficient execution model is achieved. The transition from Raw to Checked is used to pad the bytecode with multiples of 33, ensuring that the PC can be increased by 1 in any given position of the initial bytecode, and that the last opcode of the padded code will be 0x00 (STOP). Finally, bytecode that has been Checked will then undergo analysis and transition to Analysed.\npub struct Bytecode { pub bytecode: Bytes, pub state: BytecodeState, } pub enum BytecodeState { // No analysis has been performed. Raw, // The bytecode has been checked for validity. Checked { len: usize }, // The bytecode has been analysed for valid jump destinations. Analysed { len: usize, jump_map: JumpMap }, } // Pads the bytecode and ensures 0x00 (STOP) is the last opcode. pub fn to_checked(self) -\u003e Self { match self.state { BytecodeState::Raw =\u003e { let len = self.bytecode.len(); let mut padded_bytecode = Vec::with_capacity(len + 33); padded_bytecode.extend_from_slice(\u0026self.bytecode); padded_bytecode.resize(len + 33, 0); Self { bytecode: padded_bytecode.into(), state: BytecodeState::Checked { len }, } } _ =\u003e self, } } // Finds and caches valid jump destinations for later execution. pub fn to_analysed(bytecode: Bytecode) -\u003e Bytecode { let (bytecode, len) = match bytecode.state { BytecodeState::Raw =\u003e { let len = bytecode.bytecode.len(); let checked = bytecode.to_checked(); (checked.bytecode, len) } BytecodeState::Checked { len } =\u003e (bytecode.bytecode, len), _ =\u003e return bytecode, }; let jump_map = analyze(bytecode.as_ref()); Bytecode { bytecode, state: BytecodeState::Analysed { len, jump_map }, } } Additionally, analysed bytecode can be converted into BytecodeLocked, signaling it has passed all checks and analyses, thereby locking it against further modifications. Then, it will be feedable to the interpreter’s Contract.\n// Analysed bytecode. pub struct BytecodeLocked { bytecode: Bytes, original_len: usize, jump_map: JumpMap, } impl TryFrom\u003cBytecode\u003e for BytecodeLocked { type Error = (); fn try_from(bytecode: Bytecode) -\u003e Result\u003cSelf, Self::Error\u003e { if let BytecodeState::Analysed { len, jump_map } = bytecode.state { Ok(BytecodeLocked { bytecode: bytecode.bytecode, original_len: len, jump_map, }) } else { Err(()) } } } Opcodes As you may have already anticipated, efficient methods for associating opcodes with their corresponding execution logic and mnemonic representation are essential. revm achieves it thanks to the creation of an InstructionTable and an OPCODE_JUMPMAP.\nBasics Types: OpCode and Instruction The Instruction type is a function pointer with a specific signature that represents the implementation of an EVM opcode. This function takes two arguments: a mutable reference to the Interpreter and a mutable reference to the Host. Similarly to the opcode jumpmap, in this case it is also convenient to define InstructionTable, an array of instruction pointers.\n// EVM opcode function signature. pub type Instruction\u003cH\u003e = fn(\u0026mut Interpreter, \u0026mut H); // List of instruction function pointers mapped to the 256 EVM opcodes. pub type InstructionTable\u003cH\u003e = [Instruction\u003cH\u003e; 256]; By wrapping a single byte, the OpCode struct represents an individual EVM opcode in a human-readable, type-safe manner. Each byte corresponds to one of the 256 possible values defined by the OPCODE_JUMPMAP, ensuring that opcodes are only instantiated with valid values, as not all possible values are associated with an opcode.\nThe OPCODE_JUMPMAP is a static jump map array that links opcode values to their mnemonic representation. It is useful for debugging and introspection, helping devs print or log opcode names rather than hexadecimal values.\n// An EVM opcode. Always valid, as it is declared in the [`OPCODE_JUMPMAP`]. pub struct OpCode(u8); impl OpCode { // Instantiate a new opcode from a u8. pub const fn new(opcode: u8) -\u003e Option\u003cSelf\u003e { match OPCODE_JUMPMAP[opcode as usize] { Some(_) =\u003e Some(Self(opcode)), None =\u003e None, } } } After defining the basic custom types related to opcodes, the next step involves the implementation of a mechanism that not only generates but also seamlessly links these types with their corresponding execution logic. This is where the opcodes! macro comes into play. This macro that takes a series of inputs separated by commas, where each input refers to an opcode and. At the same time, each input has 3 sub-inputs separated by arrows =\u003e:\n$val:literal: opcode value as a hexadecimal number. $name:ident: mnemonic representation of the opcode. $f:expr: expression that resolves to the function implementing the instruction logic. The macro then produces several outputs:\nOpcode Constants: For each opcode provided to the macro, a constant is declared with the given name $name and hexadecimal value $val. This allows the opcodes to be referenced by name throughout the codebase. Opcode Jumpmap: As previously described, the macro creates a static jump map array that maps opcode values to their mnemonic representations. The OPCODE_JUMPMAP array is initially filled with None values. Then, the corresponding entry for each opcode is set to Some(stringify!($name)), turning the mnemonic into a string. Instruction Function Dispatcher: Finally, the macro generates a dispatcher mechanism; fn instruction() that takes an opcode value, and an EVM spec, and returns the corresponding Instruction execution logic. A match statement to map each opcode value $val to its function $f is used. If an unknown opcode is encountered, the macro defaults to control::unknown to handle undefined opcodes. macro_rules! opcodes { ($($val:literal =\u003e $name:ident =\u003e $f:expr),* $(,)?) =\u003e { // Constants for each opcode. This also takes care of duplicate names. $( pub const $name: u8 = $val; )* // Maps each opcode to its name. pub const OPCODE_JUMPMAP: [Option\u003c\u0026'static str\u003e; 256] = { let mut map = [None; 256]; let mut prev: u8 = 0; $( let val: u8 = $val; assert!(val == 0 || val \u003e prev, \"opcodes must be in asc order\"); prev = val; map[$val] = Some(stringify!($name)); )* let _ = prev; map }; // Returns the instruction function for the given opcode and spec. pub fn instruction\u003cH: Host, SPEC: Spec\u003e(opcode: u8) -\u003e Instruction\u003cH\u003e { match opcode { $($name =\u003e $f,)* _ =\u003e control::unknown, } } }; } The InstructionTable is typically generated by iterating over all possible opcode values (from 0 to 255) and calling fn instruction() with each of them. This process effectively builds an array where each index corresponds to an opcode, and where the value at that index is used as its Instruction function pointer. By defining the InstructionTable in such a way, every possible opcode is guaranteed to have an associated function -or, at least, a the default undefined implementation- in the table.\nSince the InstructionTable plays a key role in the interpreter’s execution, the benefits of this design aren’t limited to convenience; using a fixed-sized table (indexable by opcode value) allows for constant-time lookup of instruction functions. Rather than iterating through enums or using match/case statements with potentially slower lookup times, this design provides a more performant approach.\nrevm also implements a Boxed version of both types. By doing so, devs who want to implement their own even, can have closures available for BoxedInstruction at the expense of some performance. Because of that, both implementations are wrapped under an enum.\npub enum InstructionTables\u003c'a, H: Host\u003e { // `Plain` gives 10-20% faster Interpreter execution. Plain(InstructionTable\u003cH\u003e), // `Boxed` wraps the plain function pointers with closures. Boxed(BoxedInstructionTable\u003c'a, H\u003e), } The following snippet showcases how the opcodes! macro is called to instantiate the OPCODE_JUMPMAP with the map between opcode hexadecimal values and their mnemonic representation, as well as linking the fn instruction() implementation to each opcode value. Check the full code here.\nopcodes! { 0x00 =\u003e STOP =\u003e control::stop, 0x01 =\u003e ADD =\u003e arithmetic::wrapping_add, 0x02 =\u003e MUL =\u003e arithmetic::wrapping_mul, // ... 0x60 =\u003e PUSH1 =\u003e stack::push::\u003c1, H\u003e, 0x61 =\u003e PUSH2 =\u003e stack::push::\u003c2, H\u003e, // ... 0x50 =\u003e POP =\u003e stack::pop, 0x51 =\u003e MLOAD =\u003e memory::mload, 0x52 =\u003e MSTORE =\u003e memory::mstore, // ... 0xF3 =\u003e RETURN =\u003e control::ret, } Perhaps the benefits were not obvious at first, yet it should now be clear that by using a macro:\nadding opcodes becomes a matter of adding entries to its invocation. updating the logic of an opcode is a matter of redefining the function linked to its instruction function pointer. Rather than manually updating enums, or match statements, this approach establishes a separation of concerns; making the codebase less error-prone and easier to understand, test, and extend -as the opcode execution logic can evolve independently of how opcodes are defined and organized-.\nMore types: OpInfo The OpInfo struct also plays an important role in opcode handling, providing a compact and efficient way to store and access relevant information for the execution of each opcode. By packing this data into a single u32, OpInfo minimizes memory usage while maintaining quick access to opcode metadata.\npub struct OpInfo { /// Data contains few information packed inside u32: /// IS_JUMP (1bit) | IS_GAS_BLOCK_END (1bit) | IS_PUSH (1bit) | GAS (29bits) data: u32, } IS_JUMP (1 bit): Indicates if the opcode is a jump operation (JUMP or JUMPI). This information is useful for control flow management. IS_GAS_BLOCK_END (1 bit): Marks the opcode as ending a block of operations that are considered for gas calculation purposes. IS_PUSH (1 bit): Identifies the opcode as a push operation. GAS (29 bits): Stores the gas cost associated with the opcode. This allows for quick access to gas requirements, facilitating efficient gas calculation during execution. As the information is packed in a single field, to manipulate and interpret the data within OpInfo, several bitmasks and utility functions are defined:\nconst JUMP_MASK: u32 = 0x80000000; const GAS_BLOCK_END_MASK: u32 = 0x40000000; const IS_PUSH_MASK: u32 = 0x20000000; const GAS_COST_MASK: u32 = 0x1FFFFFFF; Note: We will dive deeper into gas later on the series but, as a rule of thumb, you can assume that all opcodes have a fixed gas cost: ZERO, BASE, VERYLOW, LOW, MID, HIGH, or custom values. Additionally, some opcodes will also incur a dynamic gas costs depending on their runtime behavior.\nMost of the OpInfo elements are instantiated by only informing their gas cost (as they are neither jumps, push, or end-of-block opcodes) using fn gas(). Additionally, to get the gas cost associated with an opcode, we simply need to apply the GAS_COST_MASK to the data by using a bitwise AND operator.\nimpl OpInfo { /// Creates a new [`OpInfo`] with the given gas value. pub const fn gas(gas: u64) -\u003e Self { Self { data: gas as u32 } } /// Returns the gas cost of the opcode. pub fn get_gas(self) -\u003e u32 { self.data \u0026 GAS_MASK } } For each bitmask, corresponding generator and checker functions are implemented. For the sake of brevity, we will only look at the ones related to push opcodes. On the one hand, we have the constructor fn push_opcode(), which stores the gas information in the first 29 bits, and uses a bitwise OR in conjunction with the IS_PUSH_MASK to flip the bit that sets the opcode to IS_PUSH. On the other hand, to check whether an opcode IS_PUSH, we simply need to use the IS_PUSH_MASK to check if the relevant bit is set to 1.\nimpl OpInfo { /// Creates a new push [`OpInfo`]. pub const fn push_opcode() -\u003e Self { Self { data: gas::VERYLOW as u32 | IS_PUSH_MASK, } } /// Whether the opcode is a PUSH opcode or not. pub fn is_push(self) -\u003e bool { self.data \u0026 IS_PUSH_MASK == IS_PUSH_MASK } } Finally, similar to InstructionTable or OPCODE_JUMPMAP, it is useful to create a table (a fixed-size array indexable by opcode value) with the generated OpInfo, to increase runtime performance.\nconst fn make_gas_table(spec: SpecId) -\u003e [OpInfo; 256] { let mut table = [OpInfo::none(); 256]; let mut i = 0; while i \u003c 256 { table[i] = opcode_gas_info(i as u8, spec); i += 1; } table } const fn opcode_gas_info(opcode: u8, spec: SpecId) -\u003e OpInfo { match opcode { STOP =\u003e OpInfo::gas_block_end(0), ADD =\u003e OpInfo::gas(gas::VERYLOW), MUL =\u003e OpInfo::gas(gas::LOW), // ... PUSH1 =\u003e OpInfo::push_opcode(), PUSH2 =\u003e OpInfo::push_opcode(), // ... POP =\u003e OpInfo::gas(gas::BASE), MLOAD =\u003e OpInfo::gas(gas::VERYLOW), MSTORE =\u003e OpInfo::gas(gas::VERYLOW), // ... RETURN =\u003e OpInfo::gas_block_end(0), } } Note that besides maintaining the opcodes! macro, opcode_gas_info must also be maintained for gas updates.\nLogic Implementation After analyzing all the building blocks, it is now time to dive into the implementation of each opcode. First though, let’s see how the interpreter consumes and processes each opcode in the execution loop.\nimpl Interpreter { // Executes the instruction at the current instruction pointer. // Internally it will increment instruction pointer by one. fn step\u003cFN, H: Host\u003e(\u0026mut self, instruction_table: \u0026[FN; 256], host: \u0026mut H) where FN: Fn(\u0026mut Interpreter, \u0026mut H), { // Get current opcode (hexadecimal value). let opcode = unsafe { *self.instruction_pointer }; // SAFETY: In analysis \u003e padding of bytecode to ensure last byte is STOP. // Therefore, on last instruction it will stop execution of this contract. self.instruction_pointer = unsafe { self.instruction_pointer.offset(1) }; // Execute instruction by using the [`InstructionTable`]. (instruction_table[opcode as usize])(self, host) } } Thanks to the fn step() function, as previously described, the interpreter loop processes one opcode at a time. It does so by executing the corresponging Instruction form the InstructionTable based on the processed opcode value.\nUseful Macros Before diving into the actual opcode implementations, we will first define some useful macros that are frequently used by the instructions. Other than for convenience purposes, these macros are generally used as a workaround to set interpreter results and return in case of an error, as the opcode Instruction does not return any values.\nThe gas! macro updates the acrued gas cost of the current interpreter execution. It does so by calling fn record_gas() on the gas attribute of the interpreter. If the call execution runs out of gas, it will set the InstructionResult::OutOfGas.\nmacro_rules! gas { ($interp:expr, $gas:expr) =\u003e { if !$interp.gas.record_cost($gas) { $interp.instruction_result = InstructionResult::OutOfGas; return; } }; } As the Gas struct was only presented but its implementation wasn’t shown, let’s have a look now. As the snippet below shows, fn record_cost() increases the gas used, whereas fn record_memory() increases the memory-related gas costs. In both cases, the total gas used is updated, and the returned value is false if the gas limit is exceeded.\nimpl Gas { /// Records an explicit cost. Returns `false` if gas limit is exceeded. pub fn record_cost(\u0026mut self, cost: u64) -\u003e bool { let all_used_gas = self.all_used_gas.saturating_add(cost); if self.limit \u003c all_used_gas { return false; } self.used += cost; self.all_used_gas = all_used_gas; true } /// Records memory expansion cost. Returns `false` if gas limit is exceeded. pub fn record_memory(\u0026mut self, gas_memory: u64) -\u003e bool { if gas_memory \u003e self.memory { let all_used_gas = self.used.saturating_add(gas_memory); if self.limit \u003c all_used_gas { return false; } self.memory = gas_memory; self.all_used_gas = all_used_gas; } true } } The pop! macro is a flexible procedural macro that pops up to 4 words (maximum popped by any opcode) from the stack, while handling reverts in the event of a InstructionResult::StackUnderflow. Similarly, pop_address! and pop_top! are also implemented. While pop_address! converts the resulting U256 words into Address, pop_top! pops up to 2 words and returns a reference to the new top-most item of the stack.\nmacro_rules! pop { ($interp:expr, $x1:ident) =\u003e { if $interp.stack.len() \u003c 1 { $interp.instruction_result = InstructionResult::StackUnderflow; return; } // SAFETY: Length is checked above. let $x1 = unsafe { $interp.stack.pop_unsafe() }; }; ($interp:expr, $x1:ident, $x2:ident) =\u003e { if $interp.stack.len() \u003c 2 { $interp.instruction_result = InstructionResult::StackUnderflow; return; } // SAFETY: Length is checked above. let ($x1, $x2) = unsafe { $interp.stack.pop2_unsafe() }; }; ($interp:expr, $x1:ident, $x2:ident, $x3:ident) =\u003e { if $interp.stack.len() \u003c 3 { $interp.instruction_result = InstructionResult::StackUnderflow; return; } // SAFETY: Length is checked above. let ($x1, $x2, $x3) = unsafe { $interp.stack.pop3_unsafe() }; }; ($interp:expr, $x1:ident, $x2:ident, $x3:ident, $x4:ident) =\u003e { if $interp.stack.len() \u003c 4 { $interp.instruction_result = InstructionResult::StackUnderflow; return; } // SAFETY: Length is checked above. let ($x1, $x2, $x3, $x4) = unsafe { $interp.stack.pop4_unsafe() }; }; } The push! and push_b256 macro simply push a new word (U256 or B256) into the stack. As previously explained, the reason behind its usage is the ability to set the interpreter’s InstructionResult::StackOverflow and return in case of an error (which is not possible in the instruction function definition).\nmacro_rules! push { ($interp:expr, $($x:expr),* $(,)?) =\u003e ($( match $interp.stack.push($x) { Ok(()) =\u003e {}, Err(e) =\u003e { $interp.instruction_result = e; return; } } )*) } The memory_resize! macro expands the memory if necessary. If the memory limit is reached, it will set the InstructionResult::MemoryLimitOOG. Additionally, it will calculate the extra gas of the memory expansion costs.\nmacro_rules! memory_resize { ($interp:expr, $offset:expr, $len:expr) =\u003e { memory_resize!($interp, $offset, $len, ()) }; ($interp:expr, $offset:expr, $len:expr, $ret:expr) =\u003e { let size = $offset.saturating_add($len); if size \u003e $interp.memory.len() { if $interp.memory.limit_reached(size) { $interp.instruction_result = InstructionResult::MemoryLimitOOG; return $ret; } // We are fine with saturating to usize if size is close to MAX value. let rounded_size = crate::interpreter::next_multiple_of_32(size); // Gas is calculated in EVM words (256bits). let words_num = rounded_size / 32; if !$interp.gas.record_memory(crate::gas::memory_gas(words_num)) { $interp.instruction_result = InstructionResult::MemoryLimitOOG; return $ret; } // Gas of memory expansion cost (not covered yet) $interp.memory.resize(rounded_size); } }; } If the interpreter is supposed to be in view-only mode, the check_staticcall! macro will set the InstructionResult::StateChangeStaticCall and return.\nmacro_rules! check_staticcall { ($interp:expr) =\u003e { if $interp.is_static { $interp.instruction_result = InstructionResult::StateChangeStaticCall; return; } }; } Finally, as_u64_saturated! and as_usize_or_fail! macros are useful to convert inputs to u64 (saturating to u64::MAX rather than overflowing) or usize (reverting if not possible).\nNow that the useful interpreter macros are understood, the following sections will delve into the implementation functions for various opcode instructions. In addition to the yellow paper, which provides a highly mathematical perspective, evm.codes serves as a practical, and therefore, extremely useful resource. It offers not only comprehensive and clear explanations but also features a playground to thoroughly explore the behavior of arbitrary (user-input) bytecode and calldata.\nNote: Instructions can be groupped in several ways. This article will follow revm’s groupping criteria which is similar yellow paper, but more granular.\nArithmetic Instructions The EVM has several opcodes to perform arithmetic operations based on different inputs previously loaded onto the stack.\n// Snippet of the `opcodes!` macro to showcase EVM's arithmetic opcodes, // their mnemonic representation, and their [`Instruction`]. opcodes! { 0x01 =\u003e ADD =\u003e arithmetic::wrapping_add, 0x02 =\u003e MUL =\u003e arithmetic::wrapping_mul, 0x03 =\u003e SUB =\u003e arithmetic::wrapping_sub, 0x04 =\u003e DIV =\u003e arithmetic::div, 0x05 =\u003e SDIV =\u003e arithmetic::sdiv, 0x06 =\u003e MOD =\u003e arithmetic::rem, 0x07 =\u003e SMOD =\u003e arithmetic::smod, 0x08 =\u003e ADDMOD =\u003e arithmetic::addmod, 0x09 =\u003e MULMOD =\u003e arithmetic::mulmod, 0x0A =\u003e EXP =\u003e arithmetic::exp::\u003cH, SPEC\u003e, 0x0B =\u003e SIGNEXTEND =\u003e arithmetic::signextend, } As explained in the previous article, revm is built on ruint primitive types. Thanks to this foundation, the implementation of arithmetic instructions is trivial, as it relies on the built-in methods of the U256 type defined in the imported crate. Because of this, we will focus solely on the implementation of the ADD opcode.\npub fn wrapping_add\u003cH: Host\u003e(interpreter: \u0026mut Interpreter, _host: \u0026mut H) { gas!(interpreter, gas::VERYLOW); pop_top!(interpreter, op1, op2); *op2 = op1.wrapping_add(*op2); } As previously mentioned in the useful macros section, the gas! macro will record the gas cost associated with the computation of the instruction. Then, the pop_top! macro pops up to 2 words and returns a reference to the new top-most item on the stack. fn wrapping_add() leverages this macro to seamlessly dereference the second stack input and update its value with the result of the arithmetic operation. Note that this process is equivalent to popping the words from the stack, adding them together, and then pushing the result back onto the stack. Nevertheless, by using the pop_top! macro, this operation can be executed more concisely and efficiently.\nBitwise Instructions The EVM has several opcodes to perform bitwise operations based on different inputs previously loaded onto the stack.\n// Snippet of the `opcodes!` macro to showcase EVM's bitwise opcodes, // their mnemonic representation, and their [`Instruction`]. opcodes! { 0x10 =\u003e LT =\u003e bitwise::lt, 0x11 =\u003e GT =\u003e bitwise::gt, 0x12 =\u003e SLT =\u003e bitwise::slt, 0x13 =\u003e SGT =\u003e bitwise::sgt, 0x14 =\u003e EQ =\u003e bitwise::eq, 0x15 =\u003e ISZERO =\u003e bitwise::iszero, 0x16 =\u003e AND =\u003e bitwise::bitand, 0x17 =\u003e OR =\u003e bitwise::bitor, 0x18 =\u003e XOR =\u003e bitwise::bitxor, 0x19 =\u003e NOT =\u003e bitwise::not, 0x1A =\u003e BYTE =\u003e bitwise::byte, 0x1B =\u003e SHL =\u003e bitwise::shl::\u003cH, SPEC\u003e, 0x1C =\u003e SHR =\u003e bitwise::shr::\u003cH, SPEC\u003e, 0x1D =\u003e SAR =\u003e bitwise::sar::\u003cH, SPEC\u003e, } This block of instructions is also trivial to implement thanks to the built-in methods of the U256 type. Bitwise operations can be split into two categories: bit-comparison operations, which return true or false, and bit-modifying operations. However, since the EVM uses U256 for all values, these boolean outcomes are represented as U256::from(1) (true) or U256::from(0) (false).\npub fn eq\u003cH: Host\u003e(interpreter: \u0026mut Interpreter, _host: \u0026mut H) { gas!(interpreter, gas::VERYLOW); pop_top!(interpreter, op1, op2); *op2 = U256::from(op1 == *op2); } pub fn bitand\u003cH: Host\u003e(interpreter: \u0026mut Interpreter, _host: \u0026mut H) { gas!(interpreter, gas::VERYLOW); pop_top!(interpreter, op1, op2); *op2 = op1 \u0026 *op2; } Bitwise operations follow the same approach as arithmetic operations, using the gas! and pop_top! macros to update the gas cost associated with the ongoing interpreter execution and to modify the stack accordingly.\nEnvironment Instructions Environment instructions refer to those operations that are related to information stored on the Env struct, which the interpreter can access via the fn env() method of the Host trait.\n// Snippet of the `opcodes!` macro to showcase environment opcodes, // their mnemonic representation, and their [`Instruction`]. opcodes! { 0x32 =\u003e ORIGIN =\u003e host_env::origin, 0x3A =\u003e GASPRICE =\u003e host_env::gasprice, 0x41 =\u003e COINBASE =\u003e host_env::coinbase, 0x42 =\u003e TIMESTAMP =\u003e host_env::timestamp, 0x43 =\u003e NUMBER =\u003e host_env::number, 0x44 =\u003e DIFFICULTY =\u003e host_env::difficulty::\u003cH, SPEC\u003e, 0x45 =\u003e GASLIMIT =\u003e host_env::gaslimit, 0x46 =\u003e CHAINID =\u003e host_env::chainid::\u003cH, SPEC\u003e, 0x48 =\u003e BASEFEE =\u003e host_env::basefee::\u003cH, SPEC\u003e, 0x49 =\u003e BLOBHASH =\u003e host_env::blob_hash::\u003cH, SPEC\u003e, 0x4A =\u003e BLOBBASEFEE =\u003e host_env::blob_basefee::\u003cH, SPEC\u003e, } This block of instructions is also trivial to implement, as it simply pushes new environmental information (which is easily accessible thanks to the Host trait) onto the stack. The instructions simply call the gas! and push! macros to update the gas cost associated with the ongoing interpreter execution and to modify its stack accordingly.\npub fn origin\u003cH: Host\u003e(interpreter: \u0026mut Interpreter, host: \u0026mut H) { gas!(interpreter, gas::BASE); push_b256!(interpreter, host.env().tx.caller.into_word()); } pub fn timestamp\u003cH: Host\u003e(interpreter: \u0026mut Interpreter, host: \u0026mut H) { gas!(interpreter, gas::BASE); push!(interpreter, host.env().block.timestamp); } System Instructions System instructions refer to operations related to information in the Interpreter struct, excluding Memory and Stack operations, which have their own set of opcodes.\nInstructions 0x30..0x39 relate to Contract information, whereas instruction 0x5A relates to Gas costs.\n// Snippet of the `opcodes!` macro to showcase EVM's system opcodes, // their mnemonic representation, and their [`Instruction`]. opcodes! { 0x30 =\u003e ADDRESS =\u003e system::address, 0x33 =\u003e CALLER =\u003e system::caller, 0x34 =\u003e CALLVALUE =\u003e system::callvalue, 0x35 =\u003e CALLDATALOAD =\u003e system::calldataload, 0x36 =\u003e CALLDATASIZE =\u003e system::calldatasize, 0x37 =\u003e CALLDATACOPY =\u003e system::calldatacopy, 0x38 =\u003e CODESIZE =\u003e system::codesize, 0x39 =\u003e CODECOPY =\u003e system::codecopy, 0x5A =\u003e GAS =\u003e system::gas, } Firstly, the simplest opcodes will simply push new information into the stack.\n// Push the address of the [`Contract`] address onto the stack. pub fn address\u003cH: Host\u003e(interpreter: \u0026mut Interpreter, _host: \u0026mut H) { gas!(interpreter, gas::BASE); push_b256!(interpreter, interpreter.contract.address.into_word()); } // Push the address of the [`Contract`] caller onto the stack. pub fn caller\u003cH: Host\u003e(interpreter: \u0026mut Interpreter, _host: \u0026mut H) { gas!(interpreter, gas::BASE); push_b256!(interpreter, interpreter.contract.caller.into_word()); } // Push the value of the [`Contract`] call onto the stack. pub fn callvalue\u003cH: Host\u003e(interpreter: \u0026mut Interpreter, _host: \u0026mut H) { gas!(interpreter, gas::BASE); push!(interpreter, interpreter.contract.value); } // Push the size of the [`Contract`] calldata onto the stack. pub fn calldatasize\u003cH: Host\u003e(interpreter: \u0026mut Interpreter, _host: \u0026mut H) { gas!(interpreter, gas::BASE); push!(interpreter, U256::from(interpreter.contract.input.len())); } // Push the size of the [`Contract`] code onto the stack. pub fn codesize\u003cH: Host\u003e(interpreter: \u0026mut Interpreter, _host: \u0026mut H) { gas!(interpreter, gas::BASE); push!(interpreter, U256::from(interpreter.contract.bytecode.len())); } // Push the remaining [`Gas`] value onto the stack. pub fn gas\u003cH: Host\u003e(interpreter: \u0026mut Interpreter, _host: \u0026mut H) { gas!(interpreter, gas::BASE); push!(interpreter, U256::from(interpreter.gas.remaining())); } Secondly, CALLDATALOAD opcodes will take an input from the stack (offset) and 32-bytes of calldata (starting from the offset) into the stack. If the offset is bigger than the calldata length, a zero will be pushed.\n// Push 1 word of call data into the stack. Load from `index` (offfset). pub fn calldataload\u003cH: Host\u003e(interpreter: \u0026mut Interpreter, _host: \u0026mut H) { gas!(interpreter, gas::VERYLOW); pop!(interpreter, index); let index = as_usize_saturated!(index); let load = if index \u003c interpreter.contract.input.len() { let length = 32.min(interpreter.contract.input.len() - index); let end = index + length; let mut bytes = [0u8; 32]; bytes[..length].copy_from_slice(\u0026interpreter.contract.input[index..end]); B256::new(bytes) } else { B256::ZERO }; push_b256!(interpreter, load); } Finally, COPY opcodes will take 3 inputs from the stack (memory offset, input data offset, and copy length) and store the corresponding data into memory. Note that it may be necessary to resize memory if the destination of the copied data requires to do so.\npub fn calldatacopy\u003cH: Host\u003e(interpreter: \u0026mut Interpreter, _host: \u0026mut H) { pop!(interpreter, memory_offset, data_offset, len); let len = as_usize_or_fail!(interpreter, len); gas_or_fail!(interpreter, gas::verylowcopy_cost(len as u64)); if len == 0 { return; } let memory_offset = as_usize_or_fail!(interpreter, memory_offset); let data_offset = as_usize_saturated!(data_offset); memory_resize!(interpreter, memory_offset, len); // Can't panic because memory is resized beforehand. interpreter.memory.set_data( memory_offset, data_offset, len, \u0026interpreter.contract.input, ); } pub fn codecopy\u003cH: Host\u003e(interpreter: \u0026mut Interpreter, _host: \u0026mut H) { pop!(interpreter, memory_offset, code_offset, len); let len = as_usize_or_fail!(interpreter, len); gas_or_fail!(interpreter, gas::verylowcopy_cost(len as u64)); if len == 0 { return; } let memory_offset = as_usize_or_fail!(interpreter, memory_offset); let code_offset = as_usize_saturated!(code_offset); memory_resize!(interpreter, memory_offset, len); // Can't panic because memory is resized beforehand. interpreter.memory.set_data( memory_offset, code_offset, len, interpreter.contract.bytecode.original_bytecode_slice(), ); } Stack Instructions Stack instructions refer to those operations that are solely related to stack manipulation. As such, they only require of interaction with the Stack struct of the interpreter.\n// Snippet of the `opcodes!` macro to showcase stack opcodes, // their mnemonic representation, and their [`Instruction`]. opcodes! { 0x50 =\u003e POP =\u003e stack::pop, 0x5F =\u003e PUSH0 =\u003e stack::push0::\u003cH, SPEC\u003e, // PUSH (1..32) 0x60 =\u003e PUSH1 =\u003e stack::push::\u003c1, H\u003e, 0x7F =\u003e PUSH32 =\u003e stack::push::\u003c32, H\u003e, // DUP (1..16) 0x80 =\u003e DUP1 =\u003e stack::dup::\u003c1, H\u003e, 0x8F =\u003e DUP16 =\u003e stack::dup::\u003c16, H\u003e, // SWAP (1..16) 0x90 =\u003e SWAP1 =\u003e stack::swap::\u003c1, H\u003e, 0x9F =\u003e SWAP16 =\u003e stack::swap::\u003c16, H\u003e, } The POP instruction simply calls the fn pop() method of the Stack struct, and updates the gas costs by calling the gas! macro. If there is a stack underflow, it will also update the InstructionResult.\npub fn pop\u003cH: Host\u003e(interpreter: \u0026mut Interpreter, _host: \u0026mut H) { gas!(interpreter, gas::BASE); if let Err(result) = interpreter.stack.pop() { interpreter.instruction_result = result; } } When the Stack struct was initially introduced in the previous article, only fn push() and fn pop() were showcased. Nevertheless, another convenient method with the same base principle is available: fn push_slice(). This function takes an arbitrary length slice of bytes, and pushes it onto the stack, effectively pushing several words at once. Note that it is necessary to pad the last word (32 bytes) with zeros.\nThe push operations will push an arbitrary number of words extracted from the contract bytecode into the stack. To do so, they will leverage fn push_slice() to seamlessly push several values at once.\npub fn push\u003cconst N: usize, H: Host\u003e(interpreter: \u0026mut Interpreter, _host: \u0026mut H) { gas!(interpreter, gas::VERYLOW); // SAFETY: When analyzing bytecode, trailing bytes are added, so it is safe. let ip = interpreter.instruction_pointer; if let Err(result) = interpreter .stack .push_slice(unsafe { core::slice::from_raw_parts(ip, N) }) { interpreter.instruction_result = result; return; } interpreter.instruction_pointer = unsafe { ip.add(N) }; } PUSH0 is an exception, since it simply pushes a U256::from(0) onto the stack without having to read any bytecode.\npub fn push0\u003cH: Host, SPEC: Spec\u003e(interpreter: \u0026mut Interpreter, _host: \u0026mut H) { // Check if the EVM is configured to work with SHANGAI fork check!(interpreter, SHANGHAI); gas!(interpreter, gas::BASE); if let Err(result) = interpreter.stack.push(U256::ZERO) { interpreter.instruction_result = result; } } Both SWAP and DUP opcodes will simply call their respective stack methods. Since these methods weren’t explained either, we will do so now.\nimpl Stack { /// Duplicates the `N`th value from the top of the stack. pub fn dup\u003cconst N: usize\u003e(\u0026mut self) -\u003e Result\u003c(), InstructionResult\u003e { let len = self.data.len(); if len \u003c N { Err(InstructionResult::StackUnderflow) } else if len + 1 \u003e STACK_LIMIT { Err(InstructionResult::StackOverflow) } else { // SAFETY: check for out of bounds is done above. unsafe { let data = self.data.as_mut_ptr(); core::ptr::copy_nonoverlapping(data.add(len - N), data.add(len), 1); self.data.set_len(len + 1); } Ok(()) } } /// Swaps the topmost value with the `N`th value from the top. pub fn swap\u003cconst N: usize\u003e(\u0026mut self) -\u003e Result\u003c(), InstructionResult\u003e { let len = self.data.len(); if len \u003c= N { return Err(InstructionResult::StackUnderflow); } let last = len - 1; self.data.swap(last, last - N); Ok(()) } } pub fn dup\u003cconst N: usize, H: Host\u003e(interpreter: \u0026mut Interpreter, _host: \u0026mut H) { gas!(interpreter, gas::VERYLOW); if let Err(result) = interpreter.stack.dup::\u003cN\u003e() { interpreter.instruction_result = result; } } pub fn swap\u003cconst N: usize, H: Host\u003e(interpreter: \u0026mut Interpreter, _host: \u0026mut H) { gas!(interpreter, gas::VERYLOW); if let Err(result) = interpreter.stack.swap::\u003cN\u003e() { interpreter.instruction_result = result; } } Memory Instructions Memory instructions refer to those operations that are mainly related to memory manipulation or information.\n// Snippet of the `opcodes!` macro to showcase memory opcodes, // their mnemonic representation, and their [`Instruction`]. opcodes! { 0x51 =\u003e MLOAD =\u003e memory::mload, 0x52 =\u003e MSTORE =\u003e memory::mstore, 0x53 =\u003e MSTORE8 =\u003e memory::mstore8, 0x59 =\u003e MSIZE =\u003e memory::msize, 0x5E =\u003e MCOPY =\u003e memory::mcopy::\u003cH, SPEC\u003e, } Generally speaking, memory-related instructions are quite straight forward thanks to the manipulation methods offered by the Memory struct. Those methods are “wrappers” around the core methods fn slice() (getter) and fn set() (setter), that handle conversions between types.\n// Load a memory word (32-bytes) at a given index (offset) onto the stack. pub fn mload\u003cH: Host\u003e(interpreter: \u0026mut Interpreter, _host: \u0026mut H) { gas!(interpreter, gas::VERYLOW); pop!(interpreter, index); let index = as_usize_or_fail!(interpreter, index); memory_resize!(interpreter, index, 32); push!(interpreter, interpreter.memory.get_u256(index)); } // Stores a stack word (32-bytes) at a given memory index (offset). pub fn mstore\u003cH: Host\u003e(interpreter: \u0026mut Interpreter, _host: \u0026mut H) { gas!(interpreter, gas::VERYLOW); pop!(interpreter, index, value); let index = as_usize_or_fail!(interpreter, index); memory_resize!(interpreter, index, 32); interpreter.memory.set_u256(index, value); } // Stores a stack byte at a given memory index (offset). pub fn mstore8\u003cH: Host\u003e(interpreter: \u0026mut Interpreter, _host: \u0026mut H) { gas!(interpreter, gas::VERYLOW); pop!(interpreter, index, value); let index = as_usize_or_fail!(interpreter, index); memory_resize!(interpreter, index, 1); interpreter.memory.set_byte(index, value.byte(0)) } // Push the memory size onto the stack. pub fn msize\u003cH: Host\u003e(interpreter: \u0026mut Interpreter, _host: \u0026mut H) { gas!(interpreter, gas::BASE); push!(interpreter, U256::from(interpreter.memory.len())); } MCOPY is a new opcode introduced in the Cancun fork that combines consecutive MLOAD and MSTORE instructions. The introduction of this new opcode allows for easier and cheaper data copy within memory locations.\n// EIP-5656: MCOPY - Memory copying instruction pub fn mcopy\u003cH: Host, SPEC: Spec\u003e(interpreter: \u0026mut Interpreter, _host: \u0026mut H) { check!(interpreter, CANCUN); pop!(interpreter, dst, src, len); // into usize or fail let len = as_usize_or_fail!(interpreter, len); // deduce gas gas_or_fail!(interpreter, gas::verylowcopy_cost(len as u64)); if len == 0 { return; } let dst = as_usize_or_fail!(interpreter, dst); let src = as_usize_or_fail!(interpreter, src); // resize memory memory_resize!(interpreter, max(dst, src), len); // copy memory in place interpreter.memory.copy(dst, src, len); } Moving Forward And that’s it for this deep dive into the EVM interpreter and opcodes. We’ve covered a lot, but there’s always more to explore with Ethereum’s execution engine. One major area we haven’t touched on yet involves the host-related opcodes, which play a crucial role in how smart contracts interact with the EVM.\nBecause of the length of the article, I saved that discussion for next time. In our upcoming article, we will cover the host-related opcodes, while diving into contract calls and looking at sub-execution contexts. Our exploration thus far has been guided by certain simplifications and assumptions for the sake of clarity. Yet, as we venture into the intricacies of Ethereum’s smart contract interactions and execution models, these foundational concepts will be revisited and expanded.\nSo, stay tuned! We’re just scratching the surface, and there’s plenty more to uncover about how one of the most efficient implementations ( but made in rust ™️ ) of the EVM works under the hood. See you in the next one!\n","wordCount":"6280","inLanguage":"en","datePublished":"2024-03-04T16:00:00Z","dateModified":"2024-03-04T16:00:00Z","author":{"@type":"Person","name":"0xrusowsky"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://0xrusowsky.github.io/blog/articles/revm-pt2/"},"publisher":{"@type":"Organization","name":"0xrusowsky","logo":{"@type":"ImageObject","url":"https://0xrusowsky.github.io/blog/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://0xrusowsky.github.io/blog/ accesskey=h title="0xrusowsky (Alt + H)"><img src=https://0xrusowsky.github.io/blog/images/rus.jpg alt aria-label=logo height=35>0xrusowsky</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://0xrusowsky.github.io/blog/articles/ title=Articles><span>Articles</span></a></li><li><a href=https://0xrusowsky.github.io/blog/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Ethereum Virtual Machine (in Rust) - Part 2</h1><div class=post-description>In this second article of the revm series, we will dive deeper into the EVM interpreter. We will understand how it works, especially focusing on the different opcodes.</div><div class=post-meta><span title='2024-03-04 16:00:00 +0000 UTC'>March 4, 2024</span>&nbsp;·&nbsp;30 min&nbsp;·&nbsp;0xrusowsky</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#interpreter aria-label=Interpreter>Interpreter</a><ul><li><a href=#contracts aria-label=Contracts>Contracts</a><ul><li><a href=#bytecode-type-definition-and-analysis aria-label="Bytecode: type definition and analysis">Bytecode: type definition and analysis</a></li></ul></li><li><a href=#opcodes aria-label=Opcodes>Opcodes</a><ul><li><a href=#basics-types-opcode-and-instruction aria-label="Basics Types: OpCode and Instruction">Basics Types: OpCode and Instruction</a></li><li><a href=#more-types-opinfo aria-label="More types: OpInfo">More types: OpInfo</a></li></ul></li><li><a href=#logic-implementation aria-label="Logic Implementation">Logic Implementation</a><ul><li><a href=#useful-macros aria-label="Useful Macros">Useful Macros</a></li><li><a href=#arithmetic-instructions aria-label="Arithmetic Instructions">Arithmetic Instructions</a></li><li><a href=#bitwise-instructions aria-label="Bitwise Instructions">Bitwise Instructions</a></li><li><a href=#environment-instructions aria-label="Environment Instructions">Environment Instructions</a></li><li><a href=#system-instructions aria-label="System Instructions">System Instructions</a></li><li><a href=#stack-instructions aria-label="Stack Instructions">Stack Instructions</a></li><li><a href=#memory-instructions aria-label="Memory Instructions">Memory Instructions</a></li></ul></li><li><a href=#moving-forward aria-label="Moving Forward">Moving Forward</a></li></ul></li></ul></div></details></div><div class=post-content><h1 id=interpreter>Interpreter<a hidden class=anchor aria-hidden=true href=#interpreter>#</a></h1><p>As uncovered in the <a href=../revm-pt1>previous article</a> —which I highly recommend checking out if you haven&rsquo;t yet—, the interpreter is the core engine of the EVM. It is in charge of running the execution loop that processes and executes each of the instructions stored in the bytecode. Additionally, besides the computation and returning the results of the execution, the interpreter also needs to keep track of the gas consumption.</p><p>To fulfill its tasks, the interpreter will use its attributes (contract bytecode, stack, memory, etc.) and also interact with the EVM host.</p><figure class=align-center><img loading=lazy src=/blog/images/revm/interpreter-diagram.png#center alt="Representation of revm&amp;rsquo;s interpreter."><figcaption><p><em>Representation of revm&rsquo;s interpreter.</em></p></figcaption></figure><p>The following definition of the <code>Interpreter</code> struct gives it control over all the attributes described in the diagram above. Additionally, the <code>InstructionResult</code> enum, and the <code>Contract</code> struct, are also defined.</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rs data-lang=rs><span style=display:flex><span><span style=color:#cba6f7>pub</span> <span style=color:#cba6f7>struct</span> <span style=color:#f9e2af>Interpreter</span> {
</span></span><span style=display:flex><span>    <span style=color:#6c7086;font-style:italic>// Contract information and invoking data
</span></span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic></span>    <span style=color:#cba6f7>pub</span> contract: <span style=color:#89dceb>Box</span><span style=color:#89dceb;font-weight:700>&lt;</span>Contract<span style=color:#89dceb;font-weight:700>&gt;</span>,
</span></span><span style=display:flex><span>    <span style=color:#6c7086;font-style:italic>// The current instruction pointer.
</span></span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic></span>    <span style=color:#cba6f7>pub</span> instruction_pointer: <span style=color:#89dceb;font-weight:700>*</span><span style=color:#cba6f7>const</span> <span style=color:#f38ba8>u8</span>,
</span></span><span style=display:flex><span>    <span style=color:#6c7086;font-style:italic>// Execution control flag. If not set to `Continue`, the execution will stop.
</span></span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic></span>    <span style=color:#cba6f7>pub</span> instruction_result: <span style=color:#f9e2af>InstructionResult</span>,
</span></span><span style=display:flex><span>    <span style=color:#6c7086;font-style:italic>// The gas state.
</span></span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic></span>    <span style=color:#cba6f7>pub</span> gas: <span style=color:#f9e2af>Gas</span>,
</span></span><span style=display:flex><span>    <span style=color:#6c7086;font-style:italic>// Memory. 
</span></span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic></span>    <span style=color:#6c7086;font-style:italic>// Only set while running the loop. Otherwise taken and emptied.
</span></span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic></span>    <span style=color:#cba6f7>pub</span> memory: <span style=color:#f9e2af>Memory</span>,
</span></span><span style=display:flex><span>    <span style=color:#6c7086;font-style:italic>// Stack.
</span></span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic></span>    <span style=color:#cba6f7>pub</span> stack: <span style=color:#f9e2af>Stack</span>
</span></span><span style=display:flex><span>    <span style=color:#6c7086;font-style:italic>// When the execution finished, contains the output bytes of the contract.
</span></span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic></span>    <span style=color:#cba6f7>pub</span> return_data: <span style=color:#f9e2af>Bytes</span>,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The <code>InstructionResult</code> enum categorizes the outcomes of instruction executions, providing granularity and enabling the interpreter to handle success, reverts, and errors elegantly. These components, among others, ensure the interpreter&rsquo;s smooth operation and robust error handling.</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rs data-lang=rs><span style=display:flex><span><span style=color:#cba6f7>pub</span> <span style=color:#cba6f7>enum</span> <span style=color:#f9e2af>InstructionResult</span> {
</span></span><span style=display:flex><span>    <span style=color:#6c7086;font-style:italic>// Success
</span></span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic></span>    <span style=color:#6c7086;font-style:italic>#[default]</span>
</span></span><span style=display:flex><span>    Continue <span style=color:#89dceb;font-weight:700>=</span> <span style=color:#fab387>0x00</span>, Stop, Return,
</span></span><span style=display:flex><span>    <span style=color:#6c7086;font-style:italic>// Revert
</span></span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic></span>    Revert <span style=color:#89dceb;font-weight:700>=</span> <span style=color:#fab387>0x10</span>, CallTooDeep, OutOfFunds,
</span></span><span style=display:flex><span>    <span style=color:#6c7086;font-style:italic>// Errors
</span></span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic></span>    OutOfGas <span style=color:#89dceb;font-weight:700>=</span> <span style=color:#fab387>0x50</span>, OpcodeNotFound, StackUnderflow, StackOverflow, <span style=color:#6c7086;font-style:italic>// ...
</span></span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#cba6f7>impl</span> InstructionResult {
</span></span><span style=display:flex><span>    <span style=color:#6c7086;font-style:italic>// Returns whether the result is a success.
</span></span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic></span>    <span style=color:#cba6f7>pub</span> <span style=color:#cba6f7>const</span> <span style=color:#cba6f7>fn</span> <span style=color:#89b4fa>is_ok</span>(<span style=color:#89dceb>self</span>) -&gt; <span style=color:#f38ba8>bool</span> {
</span></span><span style=display:flex><span>        <span style=color:#89b4fa>matches!</span>(<span style=color:#89dceb>self</span>, <span style=color:#cba6f7>crate</span>::<span style=color:#89b4fa>return_ok!</span>())
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6c7086;font-style:italic>// Returns whether the result is a revert.
</span></span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic></span>    <span style=color:#cba6f7>pub</span> <span style=color:#cba6f7>const</span> <span style=color:#cba6f7>fn</span> <span style=color:#89b4fa>is_revert</span>(<span style=color:#89dceb>self</span>) -&gt; <span style=color:#f38ba8>bool</span> {
</span></span><span style=display:flex><span>        <span style=color:#89b4fa>matches!</span>(<span style=color:#89dceb>self</span>, <span style=color:#cba6f7>crate</span>::<span style=color:#89b4fa>return_revert!</span>())
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6c7086;font-style:italic>// Returns whether the result is an error.
</span></span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic></span>    <span style=color:#cba6f7>pub</span> <span style=color:#cba6f7>const</span> <span style=color:#cba6f7>fn</span> <span style=color:#89b4fa>is_error</span>(<span style=color:#89dceb>self</span>) -&gt; <span style=color:#f38ba8>bool</span> {
</span></span><span style=display:flex><span>        <span style=color:#89b4fa>matches!</span>(<span style=color:#89dceb>self</span>, <span style=color:#89b4fa>return_error!</span>())
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The usage of macros is just for maintainability purposes, as they simply return the enum variants that match the outcome of the match statement. When new reason codes are added to the EVM, code maintainers simply need to add a new variant to the macro.</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rs data-lang=rs><span style=display:flex><span>macro_rules<span style=color:#89dceb;font-weight:700>!</span> return_ok {
</span></span><span style=display:flex><span>    () <span style=color:#89dceb;font-weight:700>=&gt;</span> {
</span></span><span style=display:flex><span>        InstructionResult::Continue
</span></span><span style=display:flex><span>            <span style=color:#89dceb;font-weight:700>|</span> InstructionResult::Stop
</span></span><span style=display:flex><span>            <span style=color:#89dceb;font-weight:700>|</span> InstructionResult::Return
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=contracts>Contracts<a hidden class=anchor aria-hidden=true href=#contracts>#</a></h2><p>The <code>Contract</code> struct holds all data related to the target bytecode to be executed, as well as the invoking data in its function call.</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rs data-lang=rs><span style=display:flex><span><span style=color:#6c7086;font-style:italic>// EVM contract information.
</span></span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic></span><span style=color:#cba6f7>pub</span> <span style=color:#cba6f7>struct</span> <span style=color:#f9e2af>Contract</span> {
</span></span><span style=display:flex><span>    <span style=color:#6c7086;font-style:italic>// Contracts data
</span></span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic></span>    <span style=color:#cba6f7>pub</span> input: <span style=color:#f9e2af>Bytes</span>,
</span></span><span style=display:flex><span>    <span style=color:#6c7086;font-style:italic>// Contract code, size of original code, and jump table.
</span></span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic></span>    <span style=color:#6c7086;font-style:italic>// Note that current code is extended with push padding and STOP at the end.
</span></span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic></span>    <span style=color:#cba6f7>pub</span> bytecode: <span style=color:#f9e2af>BytecodeLocked</span>,
</span></span><span style=display:flex><span>    <span style=color:#6c7086;font-style:italic>// Bytecode hash.
</span></span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic></span>    <span style=color:#cba6f7>pub</span> hash: <span style=color:#f9e2af>B256</span>,
</span></span><span style=display:flex><span>    <span style=color:#6c7086;font-style:italic>// Contract address
</span></span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic></span>    <span style=color:#cba6f7>pub</span> address: <span style=color:#f9e2af>Address</span>,
</span></span><span style=display:flex><span>    <span style=color:#6c7086;font-style:italic>// Caller of the EVM.
</span></span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic></span>    <span style=color:#cba6f7>pub</span> caller: <span style=color:#f9e2af>Address</span>,
</span></span><span style=display:flex><span>    <span style=color:#6c7086;font-style:italic>// Value send to contract.
</span></span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic></span>    <span style=color:#cba6f7>pub</span> value: <span style=color:#f9e2af>U256</span>,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Before exploring <code>BytecodeLocked</code>, let&rsquo;s examine the initialization functions for the <code>Contract</code> struct, including the standard <code>fn new()</code> method and the convenient <code>fn new_env()</code> to create a new contract instance from the current EVM environment.</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rs data-lang=rs><span style=display:flex><span><span style=color:#cba6f7>impl</span> Contract {
</span></span><span style=display:flex><span>    <span style=color:#6c7086;font-style:italic>// Instantiates a new contract by analyzing the given bytecode.
</span></span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic></span>    <span style=color:#cba6f7>pub</span> <span style=color:#cba6f7>fn</span> <span style=color:#89b4fa>new</span>(
</span></span><span style=display:flex><span>            input: <span style=color:#f9e2af>Bytes</span>,
</span></span><span style=display:flex><span>            bytecode: <span style=color:#f9e2af>Bytecode</span>,
</span></span><span style=display:flex><span>            hash: <span style=color:#f9e2af>B256</span>,
</span></span><span style=display:flex><span>            address: <span style=color:#f9e2af>Address</span>,
</span></span><span style=display:flex><span>            caller: <span style=color:#f9e2af>Address</span>,
</span></span><span style=display:flex><span>            value: <span style=color:#f9e2af>U256</span>,
</span></span><span style=display:flex><span>        ) -&gt; <span style=color:#f9e2af>Self</span> {
</span></span><span style=display:flex><span>            <span style=color:#f38ba8>let</span> bytecode <span style=color:#89dceb;font-weight:700>=</span> to_analysed(bytecode).try_into().expect(<span style=color:#a6e3a1>&#34;analysed&#34;</span>);
</span></span><span style=display:flex><span>            <span style=color:#89dceb>Self</span> {input, bytecode, hash, address, caller, value}
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6c7086;font-style:italic>// Creates a new contract from the given [`Env`].
</span></span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic></span>    <span style=color:#cba6f7>pub</span> <span style=color:#cba6f7>fn</span> <span style=color:#89b4fa>new_env</span>(env: <span style=color:#cba6f7>&amp;</span><span style=color:#f9e2af>Env</span>, bytecode: <span style=color:#f9e2af>Bytecode</span>, hash: <span style=color:#f9e2af>B256</span>) -&gt; <span style=color:#f9e2af>Self</span> {
</span></span><span style=display:flex><span>        <span style=color:#f38ba8>let</span> address <span style=color:#89dceb;font-weight:700>=</span> <span style=color:#cba6f7>match</span> env.tx.transact_to {
</span></span><span style=display:flex><span>            TransactTo::Call(caller) <span style=color:#89dceb;font-weight:700>=&gt;</span> caller,
</span></span><span style=display:flex><span>            TransactTo::Create(<span style=color:#89dceb;font-weight:700>..</span>) <span style=color:#89dceb;font-weight:700>=&gt;</span> Address::<span style=color:#f9e2af>ZERO</span>,
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>        <span style=color:#f38ba8>let</span> data <span style=color:#89dceb;font-weight:700>=</span> env.tx.data.clone();
</span></span><span style=display:flex><span>        <span style=color:#89dceb>Self</span>::new(data, bytecode, hash, address, env.tx.caller, env.tx.value)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=bytecode-type-definition-and-analysis>Bytecode: type definition and analysis<a hidden class=anchor aria-hidden=true href=#bytecode-type-definition-and-analysis>#</a></h3><p>When we explored the building blocks of the EVM, we simply mentioned that the world state holds all the basic account information, including its bytecode. Nevertheless, there is more to it.</p><p>Later on, we will analyze in depth how do push and jump-related opcodes work, but for the time being you should know that:</p><ul><li><code>PUSH</code> opcodes are characterized for consuming bytes directly from the contract bytecode, to use as inputs for the interpreter.</li><li><code>JUMP</code>, and <code>JUMPI</code> opcodes are a control-flow-type of opcodes that require a pre-defined valid jump destination <code>JUMPDEST</code> to be informed within the bytecode.</li></ul><p>Given the complex interplay between push and jump-related opcodes, verifying jump destinations during execution becomes non-trivial and inefficient. This complexity arises due to the need to differentiate between genuine jump destinations those potentially disguised as inputs from <code>PUSH</code> opcodes. By performing a pre-execution analysis of the bytecode to identify all valid jump destinations, a <code>JumpMap</code> can be created beforehand. This proactive approach streamlines execution and eliminates the inefficiency of runtime checks.</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rs data-lang=rs><span style=display:flex><span><span style=color:#6c7086;font-style:italic>// A vector where each element represents a byte from the contract code.
</span></span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic>// Each element is marked as either an invalid (0) or valid (1) jump destination.
</span></span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic></span><span style=color:#cba6f7>pub</span> <span style=color:#cba6f7>struct</span> <span style=color:#f9e2af>JumpMap</span>(<span style=color:#cba6f7>pub</span> Arc<span style=color:#89dceb;font-weight:700>&lt;</span>BitVec<span style=color:#89dceb;font-weight:700>&lt;</span><span style=color:#f38ba8>u8</span><span style=color:#89dceb;font-weight:700>&gt;&gt;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#cba6f7>impl</span> JumpMap {
</span></span><span style=display:flex><span>    <span style=color:#6c7086;font-style:italic>// Check if `pc` is a valid jump destination.
</span></span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic></span>    <span style=color:#cba6f7>pub</span> <span style=color:#cba6f7>fn</span> <span style=color:#89b4fa>is_valid</span>(<span style=color:#89dceb;font-weight:700>&amp;</span><span style=color:#89dceb>self</span>, pc: <span style=color:#f38ba8>usize</span>) -&gt; <span style=color:#f38ba8>bool</span> {
</span></span><span style=display:flex><span>        pc <span style=color:#89dceb;font-weight:700>&lt;</span> <span style=color:#89dceb>self</span>.<span style=color:#fab387>0.</span>len() <span style=color:#89dceb;font-weight:700>&amp;&amp;</span> <span style=color:#89dceb>self</span>.<span style=color:#fab387>0</span>[pc]
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic>// Analyze bytecode to build a jump map.
</span></span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic></span><span style=color:#cba6f7>fn</span> <span style=color:#89b4fa>analyze</span>(code: <span style=color:#cba6f7>&amp;</span>[<span style=color:#f38ba8>u8</span>]) -&gt; <span style=color:#f9e2af>JumpMap</span> {
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>let</span> <span style=color:#cba6f7>mut</span> jumps: <span style=color:#f9e2af>BitVec</span><span style=color:#89dceb;font-weight:700>&lt;</span><span style=color:#f38ba8>u8</span><span style=color:#89dceb;font-weight:700>&gt;</span> <span style=color:#89dceb;font-weight:700>=</span> <span style=color:#89b4fa>bitvec!</span>[<span style=color:#f38ba8>u8</span>, Lsb0; <span style=color:#fab387>0</span>; code.len()];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>let</span> range <span style=color:#89dceb;font-weight:700>=</span> code.as_ptr_range();
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>let</span> start <span style=color:#89dceb;font-weight:700>=</span> range.start;
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>let</span> <span style=color:#cba6f7>mut</span> iter <span style=color:#89dceb;font-weight:700>=</span> start;
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>let</span> end <span style=color:#89dceb;font-weight:700>=</span> range.end;
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>while</span> iter <span style=color:#89dceb;font-weight:700>&lt;</span> end {
</span></span><span style=display:flex><span>        <span style=color:#f38ba8>let</span> opcode <span style=color:#89dceb;font-weight:700>=</span> <span style=color:#cba6f7>unsafe</span> { <span style=color:#89dceb;font-weight:700>*</span>iter };
</span></span><span style=display:flex><span>        <span style=color:#cba6f7>if</span> opcode::<span style=color:#f9e2af>JUMPDEST</span> <span style=color:#89dceb;font-weight:700>==</span> opcode {
</span></span><span style=display:flex><span>            <span style=color:#6c7086;font-style:italic>// SAFETY: jumps are max length of the code
</span></span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic></span>            <span style=color:#cba6f7>unsafe</span> { jumps.set_unchecked(iter.offset_from(start) <span style=color:#cba6f7>as</span> <span style=color:#f38ba8>usize</span>, <span style=color:#fab387>true</span>) }
</span></span><span style=display:flex><span>            iter <span style=color:#89dceb;font-weight:700>=</span> <span style=color:#cba6f7>unsafe</span> { iter.offset(<span style=color:#fab387>1</span>) };
</span></span><span style=display:flex><span>        } <span style=color:#cba6f7>else</span> {
</span></span><span style=display:flex><span>            <span style=color:#f38ba8>let</span> push_offset <span style=color:#89dceb;font-weight:700>=</span> opcode.wrapping_sub(opcode::<span style=color:#f9e2af>PUSH1</span>);
</span></span><span style=display:flex><span>            <span style=color:#cba6f7>if</span> push_offset <span style=color:#89dceb;font-weight:700>&lt;</span> <span style=color:#fab387>32</span> {
</span></span><span style=display:flex><span>                <span style=color:#6c7086;font-style:italic>// SAFETY: iterator access range is checked in the while loop
</span></span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic></span>                iter <span style=color:#89dceb;font-weight:700>=</span> <span style=color:#cba6f7>unsafe</span> { iter.offset((push_offset <span style=color:#89dceb;font-weight:700>+</span> <span style=color:#fab387>2</span>) <span style=color:#cba6f7>as</span> <span style=color:#f38ba8>isize</span>) };
</span></span><span style=display:flex><span>            } <span style=color:#cba6f7>else</span> {
</span></span><span style=display:flex><span>                <span style=color:#6c7086;font-style:italic>// SAFETY: iterator access range is checked in the while loop
</span></span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic></span>                iter <span style=color:#89dceb;font-weight:700>=</span> <span style=color:#cba6f7>unsafe</span> { iter.offset(<span style=color:#fab387>1</span>) };
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    JumpMap(Arc::new(jumps))
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>As analyzing the bytecode requires some computation, for the sake of performance, it is useful to define a <code>Bytecode</code> struct with different <code>BytecodeState</code>. By defining 3 different states, a more granular and efficient execution model is achieved. The transition from <code>Raw</code> to <code>Checked</code> is used to pad the bytecode with multiples of 33, ensuring that the PC can be increased by 1 in any given position of the initial bytecode, and that the last opcode of the padded code will be <code>0x00 (STOP)</code>. Finally, bytecode that has been <code>Checked</code> will then undergo analysis and transition to <code>Analysed</code>.</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rs data-lang=rs><span style=display:flex><span><span style=color:#cba6f7>pub</span> <span style=color:#cba6f7>struct</span> <span style=color:#f9e2af>Bytecode</span> {
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>pub</span> bytecode: <span style=color:#f9e2af>Bytes</span>,
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>pub</span> state: <span style=color:#f9e2af>BytecodeState</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#cba6f7>pub</span> <span style=color:#cba6f7>enum</span> <span style=color:#f9e2af>BytecodeState</span> {
</span></span><span style=display:flex><span>    <span style=color:#6c7086;font-style:italic>// No analysis has been performed.
</span></span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic></span>    Raw,
</span></span><span style=display:flex><span>    <span style=color:#6c7086;font-style:italic>// The bytecode has been checked for validity.
</span></span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic></span>    Checked { len: <span style=color:#f38ba8>usize</span> },
</span></span><span style=display:flex><span>    <span style=color:#6c7086;font-style:italic>// The bytecode has been analysed for valid jump destinations.
</span></span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic></span>    Analysed { len: <span style=color:#f38ba8>usize</span>, jump_map: <span style=color:#f9e2af>JumpMap</span> },
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic>// Pads the bytecode and ensures 0x00 (STOP) is the last opcode.
</span></span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic></span><span style=color:#cba6f7>pub</span> <span style=color:#cba6f7>fn</span> <span style=color:#89b4fa>to_checked</span>(<span style=color:#89dceb>self</span>) -&gt; <span style=color:#f9e2af>Self</span> {
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>match</span> <span style=color:#89dceb>self</span>.state {
</span></span><span style=display:flex><span>        BytecodeState::Raw <span style=color:#89dceb;font-weight:700>=&gt;</span> {
</span></span><span style=display:flex><span>            <span style=color:#f38ba8>let</span> len <span style=color:#89dceb;font-weight:700>=</span> <span style=color:#89dceb>self</span>.bytecode.len();
</span></span><span style=display:flex><span>            <span style=color:#f38ba8>let</span> <span style=color:#cba6f7>mut</span> padded_bytecode <span style=color:#89dceb;font-weight:700>=</span> <span style=color:#89dceb>Vec</span>::with_capacity(len <span style=color:#89dceb;font-weight:700>+</span> <span style=color:#fab387>33</span>);
</span></span><span style=display:flex><span>            padded_bytecode.extend_from_slice(<span style=color:#89dceb;font-weight:700>&amp;</span><span style=color:#89dceb>self</span>.bytecode);
</span></span><span style=display:flex><span>            padded_bytecode.resize(len <span style=color:#89dceb;font-weight:700>+</span> <span style=color:#fab387>33</span>, <span style=color:#fab387>0</span>);
</span></span><span style=display:flex><span>            <span style=color:#89dceb>Self</span> {
</span></span><span style=display:flex><span>                bytecode: <span style=color:#f9e2af>padded_bytecode</span>.into(),
</span></span><span style=display:flex><span>                state: <span style=color:#f9e2af>BytecodeState</span>::Checked { len },
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        _ <span style=color:#89dceb;font-weight:700>=&gt;</span> <span style=color:#89dceb>self</span>,
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic>// Finds and caches valid jump destinations for later execution.
</span></span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic></span><span style=color:#cba6f7>pub</span> <span style=color:#cba6f7>fn</span> <span style=color:#89b4fa>to_analysed</span>(bytecode: <span style=color:#f9e2af>Bytecode</span>) -&gt; <span style=color:#f9e2af>Bytecode</span> {
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>let</span> (bytecode, len) <span style=color:#89dceb;font-weight:700>=</span> <span style=color:#cba6f7>match</span> bytecode.state {
</span></span><span style=display:flex><span>        BytecodeState::Raw <span style=color:#89dceb;font-weight:700>=&gt;</span> {
</span></span><span style=display:flex><span>            <span style=color:#f38ba8>let</span> len <span style=color:#89dceb;font-weight:700>=</span> bytecode.bytecode.len();
</span></span><span style=display:flex><span>            <span style=color:#f38ba8>let</span> checked <span style=color:#89dceb;font-weight:700>=</span> bytecode.to_checked();
</span></span><span style=display:flex><span>            (checked.bytecode, len)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        BytecodeState::Checked { len } <span style=color:#89dceb;font-weight:700>=&gt;</span> (bytecode.bytecode, len),
</span></span><span style=display:flex><span>        _ <span style=color:#89dceb;font-weight:700>=&gt;</span> <span style=color:#cba6f7>return</span> bytecode,
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>let</span> jump_map <span style=color:#89dceb;font-weight:700>=</span> analyze(bytecode.as_ref());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Bytecode {
</span></span><span style=display:flex><span>        bytecode,
</span></span><span style=display:flex><span>        state: <span style=color:#f9e2af>BytecodeState</span>::Analysed { len, jump_map },
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Additionally, analysed bytecode can be converted into <code>BytecodeLocked</code>, signaling it has passed all checks and analyses, thereby locking it against further modifications. Then, it will be feedable to the interpreter&rsquo;s <code>Contract</code>.</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rs data-lang=rs><span style=display:flex><span><span style=color:#6c7086;font-style:italic>// Analysed bytecode.
</span></span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic></span><span style=color:#cba6f7>pub</span> <span style=color:#cba6f7>struct</span> <span style=color:#f9e2af>BytecodeLocked</span> {
</span></span><span style=display:flex><span>    bytecode: <span style=color:#f9e2af>Bytes</span>,
</span></span><span style=display:flex><span>    original_len: <span style=color:#f38ba8>usize</span>,
</span></span><span style=display:flex><span>    jump_map: <span style=color:#f9e2af>JumpMap</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#cba6f7>impl</span> TryFrom<span style=color:#89dceb;font-weight:700>&lt;</span>Bytecode<span style=color:#89dceb;font-weight:700>&gt;</span> <span style=color:#cba6f7>for</span> BytecodeLocked {
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>type</span> <span style=color:#f9e2af>Error</span> <span style=color:#89dceb;font-weight:700>=</span> ();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>fn</span> <span style=color:#89b4fa>try_from</span>(bytecode: <span style=color:#f9e2af>Bytecode</span>) -&gt; <span style=color:#89dceb>Result</span><span style=color:#89dceb;font-weight:700>&lt;</span><span style=color:#89dceb>Self</span>, <span style=color:#89dceb>Self</span>::Error<span style=color:#89dceb;font-weight:700>&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#cba6f7>if</span> <span style=color:#f38ba8>let</span> BytecodeState::Analysed { len, jump_map } <span style=color:#89dceb;font-weight:700>=</span> bytecode.state {
</span></span><span style=display:flex><span>            <span style=color:#89dceb>Ok</span>(BytecodeLocked {
</span></span><span style=display:flex><span>                bytecode: <span style=color:#f9e2af>bytecode</span>.bytecode,
</span></span><span style=display:flex><span>                original_len: <span style=color:#f9e2af>len</span>,
</span></span><span style=display:flex><span>                jump_map,
</span></span><span style=display:flex><span>            })
</span></span><span style=display:flex><span>        } <span style=color:#cba6f7>else</span> {
</span></span><span style=display:flex><span>            <span style=color:#89dceb>Err</span>(())
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=opcodes>Opcodes<a hidden class=anchor aria-hidden=true href=#opcodes>#</a></h2><p>As you may have already anticipated, efficient methods for associating opcodes with their corresponding execution logic and mnemonic representation are essential. <code>revm</code> achieves it thanks to the creation of an <code>InstructionTable</code> and an <code>OPCODE_JUMPMAP</code>.</p><h3 id=basics-types-opcode-and-instruction>Basics Types: <code>OpCode</code> and <code>Instruction</code><a hidden class=anchor aria-hidden=true href=#basics-types-opcode-and-instruction>#</a></h3><p>The <code>Instruction</code> type is a function pointer with a specific signature that represents the implementation of an EVM opcode. This function takes two arguments: a mutable reference to the <code>Interpreter</code> and a mutable reference to the <code>Host</code>. Similarly to the opcode jumpmap, in this case it is also convenient to define <code>InstructionTable</code>, an array of instruction pointers.</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rs data-lang=rs><span style=display:flex><span><span style=color:#6c7086;font-style:italic>// EVM opcode function signature.
</span></span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic></span><span style=color:#cba6f7>pub</span> <span style=color:#cba6f7>type</span> <span style=color:#f9e2af>Instruction</span><span style=color:#89dceb;font-weight:700>&lt;</span>H<span style=color:#89dceb;font-weight:700>&gt;</span> <span style=color:#89dceb;font-weight:700>=</span> <span style=color:#cba6f7>fn</span>(<span style=color:#89dceb;font-weight:700>&amp;</span><span style=color:#cba6f7>mut</span> Interpreter, <span style=color:#89dceb;font-weight:700>&amp;</span><span style=color:#cba6f7>mut</span> H);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic>// List of instruction function pointers mapped to the 256 EVM opcodes.
</span></span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic></span><span style=color:#cba6f7>pub</span> <span style=color:#cba6f7>type</span> <span style=color:#f9e2af>InstructionTable</span><span style=color:#89dceb;font-weight:700>&lt;</span>H<span style=color:#89dceb;font-weight:700>&gt;</span> <span style=color:#89dceb;font-weight:700>=</span> [Instruction<span style=color:#89dceb;font-weight:700>&lt;</span>H<span style=color:#89dceb;font-weight:700>&gt;</span>; <span style=color:#fab387>256</span>];
</span></span></code></pre></div><p>By wrapping a single byte, the <code>OpCode</code> struct represents an individual EVM opcode in a human-readable, type-safe manner. Each byte corresponds to one of the 256 possible values defined by the <code>OPCODE_JUMPMAP</code>, ensuring that opcodes are only instantiated with valid values, as not all possible values are associated with an opcode.</p><p>The <code>OPCODE_JUMPMAP</code> is a static jump map array that links opcode values to their mnemonic representation. It is useful for debugging and introspection, helping devs print or log opcode names rather than hexadecimal values.</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rs data-lang=rs><span style=display:flex><span><span style=color:#6c7086;font-style:italic>// An EVM opcode. Always valid, as it is declared in the [`OPCODE_JUMPMAP`].
</span></span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic></span><span style=color:#cba6f7>pub</span> <span style=color:#cba6f7>struct</span> <span style=color:#f9e2af>OpCode</span>(<span style=color:#f38ba8>u8</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#cba6f7>impl</span> OpCode {
</span></span><span style=display:flex><span>    <span style=color:#6c7086;font-style:italic>// Instantiate a new opcode from a u8.
</span></span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic></span>    <span style=color:#cba6f7>pub</span> <span style=color:#cba6f7>const</span> <span style=color:#cba6f7>fn</span> <span style=color:#89b4fa>new</span>(opcode: <span style=color:#f38ba8>u8</span>) -&gt; <span style=color:#89dceb>Option</span><span style=color:#89dceb;font-weight:700>&lt;</span><span style=color:#89dceb>Self</span><span style=color:#89dceb;font-weight:700>&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#cba6f7>match</span> <span style=color:#f9e2af>OPCODE_JUMPMAP</span>[opcode <span style=color:#cba6f7>as</span> <span style=color:#f38ba8>usize</span>] {
</span></span><span style=display:flex><span>            <span style=color:#89dceb>Some</span>(_) <span style=color:#89dceb;font-weight:700>=&gt;</span> <span style=color:#89dceb>Some</span>(<span style=color:#89dceb>Self</span>(opcode)),
</span></span><span style=display:flex><span>            <span style=color:#89dceb>None</span> <span style=color:#89dceb;font-weight:700>=&gt;</span> <span style=color:#89dceb>None</span>,
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>After defining the basic custom types related to opcodes, the next step involves the implementation of a mechanism that not only generates but also seamlessly links these types with their corresponding execution logic. This is where the <code>opcodes!</code> macro comes into play. This macro that takes a series of inputs separated by commas, where each input refers to an opcode and. At the same time, each input has 3 sub-inputs separated by arrows <code>=></code>:</p><ul><li><code>$val:literal</code>: opcode value as a hexadecimal number.</li><li><code>$name:ident</code>: mnemonic representation of the opcode.</li><li><code>$f:expr</code>: expression that resolves to the function implementing the instruction logic.</li></ul><p>The macro then produces several outputs:</p><ul><li><strong>Opcode Constants</strong>: For each opcode provided to the macro, a constant is declared with the given name <code>$name</code> and hexadecimal value <code>$val</code>. This allows the opcodes to be referenced by name throughout the codebase.</li><li><strong>Opcode Jumpmap</strong>: As previously described, the macro creates a static jump map array that maps opcode values to their mnemonic representations. The <code>OPCODE_JUMPMAP</code> array is initially filled with <code>None</code> values. Then, the corresponding entry for each opcode is set to <code>Some(stringify!($name))</code>, turning the mnemonic into a string.</li><li><strong>Instruction Function Dispatcher</strong>: Finally, the macro generates a dispatcher mechanism; <code>fn instruction()</code> that takes an opcode value, and an EVM spec, and returns the corresponding <code>Instruction</code> execution logic. A match statement to map each opcode value <code>$val</code> to its function <code>$f</code> is used. If an unknown opcode is encountered, the macro defaults to <code>control::unknown</code> to handle undefined opcodes.</li></ul><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rs data-lang=rs><span style=display:flex><span>macro_rules<span style=color:#89dceb;font-weight:700>!</span> opcodes {
</span></span><span style=display:flex><span>    (<span style=color:#6c7086;font-style:italic>$($val</span>:<span style=color:#f9e2af>literal</span> <span style=color:#89dceb;font-weight:700>=&gt;</span> <span style=color:#6c7086;font-style:italic>$name</span>:<span style=color:#f9e2af>ident</span> <span style=color:#89dceb;font-weight:700>=&gt;</span> <span style=color:#6c7086;font-style:italic>$f</span>:<span style=color:#f9e2af>expr</span>),<span style=color:#89dceb;font-weight:700>*</span> <span style=color:#6c7086;font-style:italic>$(,</span>)<span style=color:#89dceb;font-weight:700>?</span>) <span style=color:#89dceb;font-weight:700>=&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#6c7086;font-style:italic>// Constants for each opcode. This also takes care of duplicate names.
</span></span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic></span>        <span style=color:#6c7086;font-style:italic>$(</span>
</span></span><span style=display:flex><span>            <span style=color:#cba6f7>pub</span> <span style=color:#cba6f7>const</span> <span style=color:#6c7086;font-style:italic>$name</span>: <span style=color:#f38ba8>u8</span> <span style=color:#89dceb;font-weight:700>=</span> <span style=color:#6c7086;font-style:italic>$val</span>;
</span></span><span style=display:flex><span>        )<span style=color:#89dceb;font-weight:700>*</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#6c7086;font-style:italic>// Maps each opcode to its name.
</span></span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic></span>        <span style=color:#cba6f7>pub</span> <span style=color:#cba6f7>const</span> <span style=color:#f9e2af>OPCODE_JUMPMAP</span>: [<span style=color:#89dceb>Option</span><span style=color:#89dceb;font-weight:700>&lt;&amp;</span><span style=color:#89dceb>&#39;static</span> <span style=color:#f38ba8>str</span><span style=color:#89dceb;font-weight:700>&gt;</span>; <span style=color:#fab387>256</span>] <span style=color:#89dceb;font-weight:700>=</span> {
</span></span><span style=display:flex><span>            <span style=color:#f38ba8>let</span> <span style=color:#cba6f7>mut</span> map <span style=color:#89dceb;font-weight:700>=</span> [<span style=color:#89dceb>None</span>; <span style=color:#fab387>256</span>];
</span></span><span style=display:flex><span>            <span style=color:#f38ba8>let</span> <span style=color:#cba6f7>mut</span> prev: <span style=color:#f38ba8>u8</span> <span style=color:#89dceb;font-weight:700>=</span> <span style=color:#fab387>0</span>;
</span></span><span style=display:flex><span>            <span style=color:#6c7086;font-style:italic>$(</span>
</span></span><span style=display:flex><span>                <span style=color:#f38ba8>let</span> val: <span style=color:#f38ba8>u8</span> <span style=color:#89dceb;font-weight:700>=</span> <span style=color:#6c7086;font-style:italic>$val</span>;
</span></span><span style=display:flex><span>                <span style=color:#89b4fa>assert!</span>(val <span style=color:#89dceb;font-weight:700>==</span> <span style=color:#fab387>0</span> <span style=color:#89dceb;font-weight:700>||</span> val <span style=color:#89dceb;font-weight:700>&gt;</span> prev, <span style=color:#a6e3a1>&#34;opcodes must be in asc order&#34;</span>);
</span></span><span style=display:flex><span>                prev <span style=color:#89dceb;font-weight:700>=</span> val;
</span></span><span style=display:flex><span>                map[<span style=color:#6c7086;font-style:italic>$val</span>] <span style=color:#89dceb;font-weight:700>=</span> <span style=color:#89dceb>Some</span>(<span style=color:#89b4fa>stringify!</span>(<span style=color:#6c7086;font-style:italic>$name</span>));
</span></span><span style=display:flex><span>            )<span style=color:#89dceb;font-weight:700>*</span>
</span></span><span style=display:flex><span>            <span style=color:#f38ba8>let</span> _ <span style=color:#89dceb;font-weight:700>=</span> prev;
</span></span><span style=display:flex><span>            map
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#6c7086;font-style:italic>// Returns the instruction function for the given opcode and spec.
</span></span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic></span>        <span style=color:#cba6f7>pub</span> <span style=color:#cba6f7>fn</span> <span style=color:#89b4fa>instruction</span><span style=color:#89dceb;font-weight:700>&lt;</span>H: <span style=color:#f9e2af>Host</span>, <span style=color:#f9e2af>SPEC</span>: <span style=color:#f9e2af>Spec</span><span style=color:#89dceb;font-weight:700>&gt;</span>(opcode: <span style=color:#f38ba8>u8</span>) -&gt; <span style=color:#f9e2af>Instruction</span><span style=color:#89dceb;font-weight:700>&lt;</span>H<span style=color:#89dceb;font-weight:700>&gt;</span> {
</span></span><span style=display:flex><span>            <span style=color:#cba6f7>match</span> opcode {
</span></span><span style=display:flex><span>                <span style=color:#6c7086;font-style:italic>$($name</span> <span style=color:#89dceb;font-weight:700>=&gt;</span> <span style=color:#6c7086;font-style:italic>$f</span>,)<span style=color:#89dceb;font-weight:700>*</span>
</span></span><span style=display:flex><span>                _ <span style=color:#89dceb;font-weight:700>=&gt;</span> control::unknown,
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The <code>InstructionTable</code> is typically generated by iterating over all possible opcode values (from 0 to 255) and calling <code>fn instruction()</code> with each of them. This process effectively builds an array where each index corresponds to an opcode, and where the value at that index is used as its <code>Instruction</code> function pointer. By defining the <code>InstructionTable</code> in such a way, every possible opcode is guaranteed to have an associated function -or, at least, a the default undefined implementation- in the table.</p><p>Since the <code>InstructionTable</code> plays a key role in the interpreter&rsquo;s execution, the benefits of this design aren&rsquo;t limited to convenience; using a fixed-sized table (indexable by opcode value) allows for constant-time lookup of instruction functions. Rather than iterating through enums or using match/case statements with potentially slower lookup times, this design provides a more performant approach.</p><p><code>revm</code> also implements a <code>Boxed</code> version of both types. By doing so, devs who want to implement their own even, can have closures available for <code>BoxedInstruction</code> at the expense of some performance. Because of that, both implementations are wrapped under an enum.</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rs data-lang=rs><span style=display:flex><span><span style=color:#cba6f7>pub</span> <span style=color:#cba6f7>enum</span> <span style=color:#f9e2af>InstructionTables</span><span style=color:#89dceb;font-weight:700>&lt;</span><span style=color:#89b4fa>&#39;a</span>, H: <span style=color:#f9e2af>Host</span><span style=color:#89dceb;font-weight:700>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#6c7086;font-style:italic>// `Plain` gives 10-20% faster Interpreter execution.
</span></span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic></span>    Plain(InstructionTable<span style=color:#89dceb;font-weight:700>&lt;</span>H<span style=color:#89dceb;font-weight:700>&gt;</span>),
</span></span><span style=display:flex><span>    <span style=color:#6c7086;font-style:italic>// `Boxed` wraps the plain function pointers with closures.
</span></span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic></span>    Boxed(BoxedInstructionTable<span style=color:#89dceb;font-weight:700>&lt;</span><span style=color:#89b4fa>&#39;a</span>, H<span style=color:#89dceb;font-weight:700>&gt;</span>),
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The following snippet showcases how the <code>opcodes!</code> macro is called to instantiate the <code>OPCODE_JUMPMAP</code> with the map between opcode hexadecimal values and their mnemonic representation, as well as linking the <code>fn instruction()</code> implementation to each opcode value. <a href=https://github.com/bluealloy/revm/blob/93c7ba0ff619534751df2922e7e77671b79077ff/crates/interpreter/src/instructions/opcode.rs#L94-#L357>Check the full code here</a>.</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rs data-lang=rs><span style=display:flex><span><span style=color:#89b4fa>opcodes!</span> {
</span></span><span style=display:flex><span>    <span style=color:#fab387>0x00</span> <span style=color:#89dceb;font-weight:700>=&gt;</span> <span style=color:#f9e2af>STOP</span>   <span style=color:#89dceb;font-weight:700>=&gt;</span> control::stop,
</span></span><span style=display:flex><span>    <span style=color:#fab387>0x01</span> <span style=color:#89dceb;font-weight:700>=&gt;</span> <span style=color:#f9e2af>ADD</span>    <span style=color:#89dceb;font-weight:700>=&gt;</span> arithmetic::wrapping_add,
</span></span><span style=display:flex><span>    <span style=color:#fab387>0x02</span> <span style=color:#89dceb;font-weight:700>=&gt;</span> <span style=color:#f9e2af>MUL</span>    <span style=color:#89dceb;font-weight:700>=&gt;</span> arithmetic::wrapping_mul,
</span></span><span style=display:flex><span>    <span style=color:#6c7086;font-style:italic>// ...
</span></span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic></span>    <span style=color:#fab387>0x60</span> <span style=color:#89dceb;font-weight:700>=&gt;</span> <span style=color:#f9e2af>PUSH1</span>  <span style=color:#89dceb;font-weight:700>=&gt;</span> stack::push::<span style=color:#89dceb;font-weight:700>&lt;</span><span style=color:#fab387>1</span>, H<span style=color:#89dceb;font-weight:700>&gt;</span>,
</span></span><span style=display:flex><span>    <span style=color:#fab387>0x61</span> <span style=color:#89dceb;font-weight:700>=&gt;</span> <span style=color:#f9e2af>PUSH2</span>  <span style=color:#89dceb;font-weight:700>=&gt;</span> stack::push::<span style=color:#89dceb;font-weight:700>&lt;</span><span style=color:#fab387>2</span>, H<span style=color:#89dceb;font-weight:700>&gt;</span>,
</span></span><span style=display:flex><span>    <span style=color:#6c7086;font-style:italic>// ...
</span></span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic></span>    <span style=color:#fab387>0x50</span> <span style=color:#89dceb;font-weight:700>=&gt;</span> <span style=color:#f9e2af>POP</span>    <span style=color:#89dceb;font-weight:700>=&gt;</span> stack::pop,
</span></span><span style=display:flex><span>    <span style=color:#fab387>0x51</span> <span style=color:#89dceb;font-weight:700>=&gt;</span> <span style=color:#f9e2af>MLOAD</span>  <span style=color:#89dceb;font-weight:700>=&gt;</span> memory::mload,
</span></span><span style=display:flex><span>    <span style=color:#fab387>0x52</span> <span style=color:#89dceb;font-weight:700>=&gt;</span> <span style=color:#f9e2af>MSTORE</span> <span style=color:#89dceb;font-weight:700>=&gt;</span> memory::mstore,
</span></span><span style=display:flex><span>    <span style=color:#6c7086;font-style:italic>// ...
</span></span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic></span>    <span style=color:#fab387>0xF3</span> <span style=color:#89dceb;font-weight:700>=&gt;</span> <span style=color:#f9e2af>RETURN</span> <span style=color:#89dceb;font-weight:700>=&gt;</span> control::ret,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Perhaps the benefits were not obvious at first, yet it should now be clear that by using a macro:</p><ul><li>adding opcodes becomes a matter of adding entries to its invocation.</li><li>updating the logic of an opcode is a matter of redefining the function linked to its instruction function pointer.</li></ul><p>Rather than manually updating enums, or match statements, this approach establishes a separation of concerns; making the codebase less error-prone and easier to understand, test, and extend -as the opcode execution logic can evolve independently of how opcodes are defined and organized-.</p><h3 id=more-types-opinfo>More types: <code>OpInfo</code><a hidden class=anchor aria-hidden=true href=#more-types-opinfo>#</a></h3><p>The <code>OpInfo</code> struct also plays an important role in opcode handling, providing a compact and efficient way to store and access relevant information for the execution of each opcode. By packing this data into a single u32, <code>OpInfo</code> minimizes memory usage while maintaining quick access to opcode metadata.</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rs data-lang=rs><span style=display:flex><span><span style=color:#cba6f7>pub</span> <span style=color:#cba6f7>struct</span> <span style=color:#f9e2af>OpInfo</span> {
</span></span><span style=display:flex><span>    <span style=color:#6c7086>/// Data contains few information packed inside u32:
</span></span></span><span style=display:flex><span><span style=color:#6c7086></span>    <span style=color:#6c7086>/// IS_JUMP (1bit) | IS_GAS_BLOCK_END (1bit) | IS_PUSH (1bit) | GAS (29bits)
</span></span></span><span style=display:flex><span><span style=color:#6c7086></span>    data: <span style=color:#f38ba8>u32</span>,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li><code>IS_JUMP</code> <strong>(1 bit):</strong> Indicates if the opcode is a jump operation (<code>JUMP</code> or <code>JUMPI</code>). This information is useful for control flow management.</li><li><code>IS_GAS_BLOCK_END</code> <strong>(1 bit):</strong> Marks the opcode as ending a block of operations that are considered for gas calculation purposes.</li><li><code>IS_PUSH</code> <strong>(1 bit):</strong> Identifies the opcode as a push operation.</li><li><code>GAS</code> <strong>(29 bits)</strong>: Stores the gas cost associated with the opcode. This allows for quick access to gas requirements, facilitating efficient gas calculation during execution.</li></ul><p>As the information is packed in a single field, to manipulate and interpret the <code>data</code> within <code>OpInfo</code>, several bitmasks and utility functions are defined:</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rs data-lang=rs><span style=display:flex><span><span style=color:#cba6f7>const</span> <span style=color:#f9e2af>JUMP_MASK</span>: <span style=color:#f38ba8>u32</span> <span style=color:#89dceb;font-weight:700>=</span> <span style=color:#fab387>0x80000000</span>;
</span></span><span style=display:flex><span><span style=color:#cba6f7>const</span> <span style=color:#f9e2af>GAS_BLOCK_END_MASK</span>: <span style=color:#f38ba8>u32</span> <span style=color:#89dceb;font-weight:700>=</span> <span style=color:#fab387>0x40000000</span>;
</span></span><span style=display:flex><span><span style=color:#cba6f7>const</span> <span style=color:#f9e2af>IS_PUSH_MASK</span>: <span style=color:#f38ba8>u32</span> <span style=color:#89dceb;font-weight:700>=</span> <span style=color:#fab387>0x20000000</span>;
</span></span><span style=display:flex><span><span style=color:#cba6f7>const</span> <span style=color:#f9e2af>GAS_COST_MASK</span>: <span style=color:#f38ba8>u32</span> <span style=color:#89dceb;font-weight:700>=</span> <span style=color:#fab387>0x1FFFFFFF</span>;
</span></span></code></pre></div><p><em>Note: We will dive deeper into gas later on the series but, as a rule of thumb, you can assume that all opcodes have a fixed gas cost: <code>ZERO</code>, <code>BASE</code>, <code>VERYLOW</code>, <code>LOW</code>, <code>MID</code>, <code>HIGH</code>, or custom values. Additionally, some opcodes will also incur a dynamic gas costs depending on their runtime behavior.</em></p><p>Most of the <code>OpInfo</code> elements are instantiated by only informing their gas cost (as they are neither jumps, push, or end-of-block opcodes) using <code>fn gas()</code>. Additionally, to get the gas cost associated with an opcode, we simply need to apply the <code>GAS_COST_MASK</code> to the data by using a bitwise <code>AND</code> operator.</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rs data-lang=rs><span style=display:flex><span><span style=color:#cba6f7>impl</span> OpInfo {
</span></span><span style=display:flex><span>    <span style=color:#6c7086>/// Creates a new [`OpInfo`] with the given gas value.
</span></span></span><span style=display:flex><span><span style=color:#6c7086></span>    <span style=color:#cba6f7>pub</span> <span style=color:#cba6f7>const</span> <span style=color:#cba6f7>fn</span> <span style=color:#89b4fa>gas</span>(gas: <span style=color:#f38ba8>u64</span>) -&gt; <span style=color:#f9e2af>Self</span> {
</span></span><span style=display:flex><span>        <span style=color:#89dceb>Self</span> { data: <span style=color:#f9e2af>gas</span> <span style=color:#cba6f7>as</span> <span style=color:#f38ba8>u32</span> }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6c7086>/// Returns the gas cost of the opcode.
</span></span></span><span style=display:flex><span><span style=color:#6c7086></span>    <span style=color:#cba6f7>pub</span> <span style=color:#cba6f7>fn</span> <span style=color:#89b4fa>get_gas</span>(<span style=color:#89dceb>self</span>) -&gt; <span style=color:#f38ba8>u32</span> {
</span></span><span style=display:flex><span>        <span style=color:#89dceb>self</span>.data <span style=color:#89dceb;font-weight:700>&amp;</span> <span style=color:#f9e2af>GAS_MASK</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>For each bitmask, corresponding generator and checker functions are implemented. For the sake of brevity, we will only look at the ones related to push opcodes. On the one hand, we have the constructor <code>fn push_opcode()</code>, which stores the gas information in the first 29 bits, and uses a bitwise <code>OR</code> in conjunction with the <code>IS_PUSH_MASK</code> to flip the bit that sets the opcode to <code>IS_PUSH</code>. On the other hand, to check whether an opcode <code>IS_PUSH</code>, we simply need to use the <code>IS_PUSH_MASK</code> to check if the relevant bit is set to 1.</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rs data-lang=rs><span style=display:flex><span><span style=color:#cba6f7>impl</span> OpInfo {
</span></span><span style=display:flex><span>    <span style=color:#6c7086>/// Creates a new push [`OpInfo`].
</span></span></span><span style=display:flex><span><span style=color:#6c7086></span>    <span style=color:#cba6f7>pub</span> <span style=color:#cba6f7>const</span> <span style=color:#cba6f7>fn</span> <span style=color:#89b4fa>push_opcode</span>() -&gt; <span style=color:#f9e2af>Self</span> {
</span></span><span style=display:flex><span>        <span style=color:#89dceb>Self</span> {
</span></span><span style=display:flex><span>            data: <span style=color:#f9e2af>gas</span>::<span style=color:#f9e2af>VERYLOW</span> <span style=color:#cba6f7>as</span> <span style=color:#f38ba8>u32</span> <span style=color:#89dceb;font-weight:700>|</span> <span style=color:#f9e2af>IS_PUSH_MASK</span>,
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6c7086>/// Whether the opcode is a PUSH opcode or not.
</span></span></span><span style=display:flex><span><span style=color:#6c7086></span>    <span style=color:#cba6f7>pub</span> <span style=color:#cba6f7>fn</span> <span style=color:#89b4fa>is_push</span>(<span style=color:#89dceb>self</span>) -&gt; <span style=color:#f38ba8>bool</span> {
</span></span><span style=display:flex><span>        <span style=color:#89dceb>self</span>.data <span style=color:#89dceb;font-weight:700>&amp;</span> <span style=color:#f9e2af>IS_PUSH_MASK</span> <span style=color:#89dceb;font-weight:700>==</span> <span style=color:#f9e2af>IS_PUSH_MASK</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Finally, similar to <code>InstructionTable</code> or <code>OPCODE_JUMPMAP</code>, it is useful to create a table (a fixed-size array indexable by opcode value) with the generated <code>OpInfo</code>, to increase runtime performance.</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rs data-lang=rs><span style=display:flex><span><span style=color:#cba6f7>const</span> <span style=color:#cba6f7>fn</span> <span style=color:#89b4fa>make_gas_table</span>(spec: <span style=color:#f9e2af>SpecId</span>) -&gt; [OpInfo; <span style=color:#fab387>256</span>] {
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>let</span> <span style=color:#cba6f7>mut</span> table <span style=color:#89dceb;font-weight:700>=</span> [OpInfo::none(); <span style=color:#fab387>256</span>];
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>let</span> <span style=color:#cba6f7>mut</span> i <span style=color:#89dceb;font-weight:700>=</span> <span style=color:#fab387>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>while</span> i <span style=color:#89dceb;font-weight:700>&lt;</span> <span style=color:#fab387>256</span> {
</span></span><span style=display:flex><span>        table[i] <span style=color:#89dceb;font-weight:700>=</span> opcode_gas_info(i <span style=color:#cba6f7>as</span> <span style=color:#f38ba8>u8</span>, spec);
</span></span><span style=display:flex><span>        i <span style=color:#89dceb;font-weight:700>+=</span> <span style=color:#fab387>1</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    table
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#cba6f7>const</span> <span style=color:#cba6f7>fn</span> <span style=color:#89b4fa>opcode_gas_info</span>(opcode: <span style=color:#f38ba8>u8</span>, spec: <span style=color:#f9e2af>SpecId</span>) -&gt; <span style=color:#f9e2af>OpInfo</span> {
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>match</span> opcode {
</span></span><span style=display:flex><span>        <span style=color:#f9e2af>STOP</span> <span style=color:#89dceb;font-weight:700>=&gt;</span> OpInfo::gas_block_end(<span style=color:#fab387>0</span>),
</span></span><span style=display:flex><span>        <span style=color:#f9e2af>ADD</span> <span style=color:#89dceb;font-weight:700>=&gt;</span> OpInfo::gas(gas::<span style=color:#f9e2af>VERYLOW</span>),
</span></span><span style=display:flex><span>        <span style=color:#f9e2af>MUL</span> <span style=color:#89dceb;font-weight:700>=&gt;</span> OpInfo::gas(gas::<span style=color:#f9e2af>LOW</span>),
</span></span><span style=display:flex><span>        <span style=color:#6c7086;font-style:italic>// ...
</span></span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic></span>        <span style=color:#f9e2af>PUSH1</span> <span style=color:#89dceb;font-weight:700>=&gt;</span> OpInfo::push_opcode(),
</span></span><span style=display:flex><span>        <span style=color:#f9e2af>PUSH2</span> <span style=color:#89dceb;font-weight:700>=&gt;</span> OpInfo::push_opcode(),
</span></span><span style=display:flex><span>        <span style=color:#6c7086;font-style:italic>// ...
</span></span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic></span>        <span style=color:#f9e2af>POP</span> <span style=color:#89dceb;font-weight:700>=&gt;</span> OpInfo::gas(gas::<span style=color:#f9e2af>BASE</span>),
</span></span><span style=display:flex><span>        <span style=color:#f9e2af>MLOAD</span> <span style=color:#89dceb;font-weight:700>=&gt;</span> OpInfo::gas(gas::<span style=color:#f9e2af>VERYLOW</span>),
</span></span><span style=display:flex><span>        <span style=color:#f9e2af>MSTORE</span> <span style=color:#89dceb;font-weight:700>=&gt;</span> OpInfo::gas(gas::<span style=color:#f9e2af>VERYLOW</span>),
</span></span><span style=display:flex><span>        <span style=color:#6c7086;font-style:italic>// ...
</span></span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic></span>        <span style=color:#f9e2af>RETURN</span> <span style=color:#89dceb;font-weight:700>=&gt;</span> OpInfo::gas_block_end(<span style=color:#fab387>0</span>),
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Note that besides maintaining the <code>opcodes!</code> macro, <code>opcode_gas_info</code> must also be maintained for gas updates.</p><h2 id=logic-implementation>Logic Implementation<a hidden class=anchor aria-hidden=true href=#logic-implementation>#</a></h2><p>After analyzing all the building blocks, it is now time to dive into the implementation of each opcode. First though, let&rsquo;s see how the interpreter consumes and processes each opcode in the execution loop.</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rs data-lang=rs><span style=display:flex><span><span style=color:#cba6f7>impl</span> Interpreter {
</span></span><span style=display:flex><span>    <span style=color:#6c7086;font-style:italic>// Executes the instruction at the current instruction pointer.
</span></span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic></span>    <span style=color:#6c7086;font-style:italic>// Internally it will increment instruction pointer by one.
</span></span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic></span>    <span style=color:#cba6f7>fn</span> <span style=color:#89b4fa>step</span><span style=color:#89dceb;font-weight:700>&lt;</span><span style=color:#f9e2af>FN</span>, H: <span style=color:#f9e2af>Host</span><span style=color:#89dceb;font-weight:700>&gt;</span>(<span style=color:#89dceb;font-weight:700>&amp;</span><span style=color:#cba6f7>mut</span> <span style=color:#89dceb>self</span>, instruction_table: <span style=color:#cba6f7>&amp;</span>[<span style=color:#f9e2af>FN</span>; <span style=color:#fab387>256</span>], host: <span style=color:#cba6f7>&amp;</span><span style=color:#f9e2af>mut</span> H)
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>where</span>
</span></span><span style=display:flex><span>        <span style=color:#f9e2af>FN</span>: <span style=color:#89dceb>Fn</span>(<span style=color:#89dceb;font-weight:700>&amp;</span><span style=color:#cba6f7>mut</span> Interpreter, <span style=color:#89dceb;font-weight:700>&amp;</span><span style=color:#cba6f7>mut</span> H),
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#6c7086;font-style:italic>// Get current opcode (hexadecimal value).
</span></span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic></span>        <span style=color:#f38ba8>let</span> opcode <span style=color:#89dceb;font-weight:700>=</span> <span style=color:#cba6f7>unsafe</span> { <span style=color:#89dceb;font-weight:700>*</span><span style=color:#89dceb>self</span>.instruction_pointer };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#6c7086;font-style:italic>// SAFETY: In analysis &gt; padding of bytecode to ensure last byte is STOP.
</span></span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic></span>        <span style=color:#6c7086;font-style:italic>// Therefore, on last instruction it will stop execution of this contract.
</span></span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic></span>        <span style=color:#89dceb>self</span>.instruction_pointer <span style=color:#89dceb;font-weight:700>=</span> <span style=color:#cba6f7>unsafe</span> { <span style=color:#89dceb>self</span>.instruction_pointer.offset(<span style=color:#fab387>1</span>) };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#6c7086;font-style:italic>// Execute instruction by using the [`InstructionTable`].
</span></span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic></span>        (instruction_table[opcode <span style=color:#cba6f7>as</span> <span style=color:#f38ba8>usize</span>])(<span style=color:#89dceb>self</span>, host)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Thanks to the <code>fn step()</code> function, as previously described, the interpreter loop processes one opcode at a time. It does so by executing the corresponging <code>Instruction</code> form the <code>InstructionTable</code> based on the processed opcode value.</p><h3 id=useful-macros>Useful Macros<a hidden class=anchor aria-hidden=true href=#useful-macros>#</a></h3><p>Before diving into the actual opcode implementations, we will first define some useful macros that are frequently used by the instructions. Other than for convenience purposes, these macros are generally used as a workaround to set interpreter results and return in case of an error, as the opcode <code>Instruction</code> does not return any values.</p><p>The <code>gas!</code> macro updates the acrued gas cost of the current interpreter execution. It does so by calling <code>fn record_gas()</code> on the gas attribute of the interpreter. If the call execution runs out of gas, it will set the <code>InstructionResult::OutOfGas</code>.</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rs data-lang=rs><span style=display:flex><span>macro_rules<span style=color:#89dceb;font-weight:700>!</span> gas {
</span></span><span style=display:flex><span>    (<span style=color:#6c7086;font-style:italic>$interp</span>:<span style=color:#f9e2af>expr</span>, <span style=color:#6c7086;font-style:italic>$gas</span>:<span style=color:#f9e2af>expr</span>) <span style=color:#89dceb;font-weight:700>=&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#cba6f7>if</span> <span style=color:#89dceb;font-weight:700>!</span><span style=color:#6c7086;font-style:italic>$interp</span>.gas.record_cost(<span style=color:#6c7086;font-style:italic>$gas</span>) {
</span></span><span style=display:flex><span>            <span style=color:#6c7086;font-style:italic>$interp</span>.instruction_result <span style=color:#89dceb;font-weight:700>=</span> InstructionResult::OutOfGas;
</span></span><span style=display:flex><span>            <span style=color:#cba6f7>return</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>As the <code>Gas</code> struct <a href=../revm-pt1/#gas>was only presented</a> but its implementation wasn&rsquo;t shown, let&rsquo;s have a look now. As the snippet below shows, <code>fn record_cost()</code> increases the gas used, whereas <code>fn record_memory()</code> increases the memory-related gas costs. In both cases, the total gas used is updated, and the returned value is <code>false</code> if the gas limit is exceeded.</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rs data-lang=rs><span style=display:flex><span><span style=color:#cba6f7>impl</span> Gas {
</span></span><span style=display:flex><span>    <span style=color:#6c7086>/// Records an explicit cost. Returns `false` if gas limit is exceeded.
</span></span></span><span style=display:flex><span><span style=color:#6c7086></span>    <span style=color:#cba6f7>pub</span> <span style=color:#cba6f7>fn</span> <span style=color:#89b4fa>record_cost</span>(<span style=color:#89dceb;font-weight:700>&amp;</span><span style=color:#cba6f7>mut</span> <span style=color:#89dceb>self</span>, cost: <span style=color:#f38ba8>u64</span>) -&gt; <span style=color:#f38ba8>bool</span> {
</span></span><span style=display:flex><span>        <span style=color:#f38ba8>let</span> all_used_gas <span style=color:#89dceb;font-weight:700>=</span> <span style=color:#89dceb>self</span>.all_used_gas.saturating_add(cost);
</span></span><span style=display:flex><span>        <span style=color:#cba6f7>if</span> <span style=color:#89dceb>self</span>.limit <span style=color:#89dceb;font-weight:700>&lt;</span> all_used_gas {
</span></span><span style=display:flex><span>            <span style=color:#cba6f7>return</span> <span style=color:#fab387>false</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#89dceb>self</span>.used <span style=color:#89dceb;font-weight:700>+=</span> cost;
</span></span><span style=display:flex><span>        <span style=color:#89dceb>self</span>.all_used_gas <span style=color:#89dceb;font-weight:700>=</span> all_used_gas;
</span></span><span style=display:flex><span>        <span style=color:#fab387>true</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6c7086>/// Records memory expansion cost. Returns `false` if gas limit is exceeded.
</span></span></span><span style=display:flex><span><span style=color:#6c7086></span>    <span style=color:#cba6f7>pub</span> <span style=color:#cba6f7>fn</span> <span style=color:#89b4fa>record_memory</span>(<span style=color:#89dceb;font-weight:700>&amp;</span><span style=color:#cba6f7>mut</span> <span style=color:#89dceb>self</span>, gas_memory: <span style=color:#f38ba8>u64</span>) -&gt; <span style=color:#f38ba8>bool</span> {
</span></span><span style=display:flex><span>        <span style=color:#cba6f7>if</span> gas_memory <span style=color:#89dceb;font-weight:700>&gt;</span> <span style=color:#89dceb>self</span>.memory {
</span></span><span style=display:flex><span>            <span style=color:#f38ba8>let</span> all_used_gas <span style=color:#89dceb;font-weight:700>=</span> <span style=color:#89dceb>self</span>.used.saturating_add(gas_memory);
</span></span><span style=display:flex><span>            <span style=color:#cba6f7>if</span> <span style=color:#89dceb>self</span>.limit <span style=color:#89dceb;font-weight:700>&lt;</span> all_used_gas {
</span></span><span style=display:flex><span>                <span style=color:#cba6f7>return</span> <span style=color:#fab387>false</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#89dceb>self</span>.memory <span style=color:#89dceb;font-weight:700>=</span> gas_memory;
</span></span><span style=display:flex><span>            <span style=color:#89dceb>self</span>.all_used_gas <span style=color:#89dceb;font-weight:700>=</span> all_used_gas;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#fab387>true</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The <code>pop!</code> macro is a flexible procedural macro that pops up to 4 words (maximum popped by any opcode) from the stack, while handling reverts in the event of a <code>InstructionResult::StackUnderflow</code>. Similarly, <code>pop_address!</code> and <code>pop_top!</code> are also implemented. While <code>pop_address!</code> converts the resulting <code>U256</code> words into <code>Address</code>, <code>pop_top!</code> pops up to 2 words and returns a reference to the new top-most item of the stack.</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rs data-lang=rs><span style=display:flex><span>macro_rules<span style=color:#89dceb;font-weight:700>!</span> pop {
</span></span><span style=display:flex><span>    (<span style=color:#6c7086;font-style:italic>$interp</span>:<span style=color:#f9e2af>expr</span>, <span style=color:#6c7086;font-style:italic>$x1</span>:<span style=color:#f9e2af>ident</span>) <span style=color:#89dceb;font-weight:700>=&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#cba6f7>if</span> <span style=color:#6c7086;font-style:italic>$interp</span>.stack.len() <span style=color:#89dceb;font-weight:700>&lt;</span> <span style=color:#fab387>1</span> {
</span></span><span style=display:flex><span>            <span style=color:#6c7086;font-style:italic>$interp</span>.instruction_result <span style=color:#89dceb;font-weight:700>=</span> InstructionResult::StackUnderflow;
</span></span><span style=display:flex><span>            <span style=color:#cba6f7>return</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#6c7086;font-style:italic>// SAFETY: Length is checked above.
</span></span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic></span>        <span style=color:#f38ba8>let</span> <span style=color:#6c7086;font-style:italic>$x1</span> <span style=color:#89dceb;font-weight:700>=</span> <span style=color:#cba6f7>unsafe</span> { <span style=color:#6c7086;font-style:italic>$interp</span>.stack.pop_unsafe() };
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>    (<span style=color:#6c7086;font-style:italic>$interp</span>:<span style=color:#f9e2af>expr</span>, <span style=color:#6c7086;font-style:italic>$x1</span>:<span style=color:#f9e2af>ident</span>, <span style=color:#6c7086;font-style:italic>$x2</span>:<span style=color:#f9e2af>ident</span>) <span style=color:#89dceb;font-weight:700>=&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#cba6f7>if</span> <span style=color:#6c7086;font-style:italic>$interp</span>.stack.len() <span style=color:#89dceb;font-weight:700>&lt;</span> <span style=color:#fab387>2</span> {
</span></span><span style=display:flex><span>            <span style=color:#6c7086;font-style:italic>$interp</span>.instruction_result <span style=color:#89dceb;font-weight:700>=</span> InstructionResult::StackUnderflow;
</span></span><span style=display:flex><span>            <span style=color:#cba6f7>return</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#6c7086;font-style:italic>// SAFETY: Length is checked above.
</span></span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic></span>        <span style=color:#f38ba8>let</span> (<span style=color:#6c7086;font-style:italic>$x1</span>, <span style=color:#6c7086;font-style:italic>$x2</span>) <span style=color:#89dceb;font-weight:700>=</span> <span style=color:#cba6f7>unsafe</span> { <span style=color:#6c7086;font-style:italic>$interp</span>.stack.pop2_unsafe() };
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>    (<span style=color:#6c7086;font-style:italic>$interp</span>:<span style=color:#f9e2af>expr</span>, <span style=color:#6c7086;font-style:italic>$x1</span>:<span style=color:#f9e2af>ident</span>, <span style=color:#6c7086;font-style:italic>$x2</span>:<span style=color:#f9e2af>ident</span>, <span style=color:#6c7086;font-style:italic>$x3</span>:<span style=color:#f9e2af>ident</span>) <span style=color:#89dceb;font-weight:700>=&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#cba6f7>if</span> <span style=color:#6c7086;font-style:italic>$interp</span>.stack.len() <span style=color:#89dceb;font-weight:700>&lt;</span> <span style=color:#fab387>3</span> {
</span></span><span style=display:flex><span>            <span style=color:#6c7086;font-style:italic>$interp</span>.instruction_result <span style=color:#89dceb;font-weight:700>=</span> InstructionResult::StackUnderflow;
</span></span><span style=display:flex><span>            <span style=color:#cba6f7>return</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#6c7086;font-style:italic>// SAFETY: Length is checked above.
</span></span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic></span>        <span style=color:#f38ba8>let</span> (<span style=color:#6c7086;font-style:italic>$x1</span>, <span style=color:#6c7086;font-style:italic>$x2</span>, <span style=color:#6c7086;font-style:italic>$x3</span>) <span style=color:#89dceb;font-weight:700>=</span> <span style=color:#cba6f7>unsafe</span> { <span style=color:#6c7086;font-style:italic>$interp</span>.stack.pop3_unsafe() };
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>    (<span style=color:#6c7086;font-style:italic>$interp</span>:<span style=color:#f9e2af>expr</span>, <span style=color:#6c7086;font-style:italic>$x1</span>:<span style=color:#f9e2af>ident</span>, <span style=color:#6c7086;font-style:italic>$x2</span>:<span style=color:#f9e2af>ident</span>, <span style=color:#6c7086;font-style:italic>$x3</span>:<span style=color:#f9e2af>ident</span>, <span style=color:#6c7086;font-style:italic>$x4</span>:<span style=color:#f9e2af>ident</span>) <span style=color:#89dceb;font-weight:700>=&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#cba6f7>if</span> <span style=color:#6c7086;font-style:italic>$interp</span>.stack.len() <span style=color:#89dceb;font-weight:700>&lt;</span> <span style=color:#fab387>4</span> {
</span></span><span style=display:flex><span>            <span style=color:#6c7086;font-style:italic>$interp</span>.instruction_result <span style=color:#89dceb;font-weight:700>=</span> InstructionResult::StackUnderflow;
</span></span><span style=display:flex><span>            <span style=color:#cba6f7>return</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#6c7086;font-style:italic>// SAFETY: Length is checked above.
</span></span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic></span>        <span style=color:#f38ba8>let</span> (<span style=color:#6c7086;font-style:italic>$x1</span>, <span style=color:#6c7086;font-style:italic>$x2</span>, <span style=color:#6c7086;font-style:italic>$x3</span>, <span style=color:#6c7086;font-style:italic>$x4</span>) <span style=color:#89dceb;font-weight:700>=</span> <span style=color:#cba6f7>unsafe</span> { <span style=color:#6c7086;font-style:italic>$interp</span>.stack.pop4_unsafe() };
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The <code>push!</code> and <code>push_b256</code> macro simply push a new word (<code>U256</code> or <code>B256</code>) into the stack. As previously explained, the reason behind its usage is the ability to set the interpreter&rsquo;s <code>InstructionResult::StackOverflow</code> and return in case of an error (which is not possible in the instruction function definition).</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rs data-lang=rs><span style=display:flex><span>macro_rules<span style=color:#89dceb;font-weight:700>!</span> push {
</span></span><span style=display:flex><span>    (<span style=color:#6c7086;font-style:italic>$interp</span>:<span style=color:#f9e2af>expr</span>, <span style=color:#6c7086;font-style:italic>$($x</span>:<span style=color:#f9e2af>expr</span>),<span style=color:#89dceb;font-weight:700>*</span> <span style=color:#6c7086;font-style:italic>$(,</span>)<span style=color:#89dceb;font-weight:700>?</span>) <span style=color:#89dceb;font-weight:700>=&gt;</span> (<span style=color:#6c7086;font-style:italic>$(</span>
</span></span><span style=display:flex><span>        <span style=color:#cba6f7>match</span> <span style=color:#6c7086;font-style:italic>$interp</span>.stack.push(<span style=color:#6c7086;font-style:italic>$x</span>) {
</span></span><span style=display:flex><span>            <span style=color:#89dceb>Ok</span>(()) <span style=color:#89dceb;font-weight:700>=&gt;</span> {},
</span></span><span style=display:flex><span>            <span style=color:#89dceb>Err</span>(e) <span style=color:#89dceb;font-weight:700>=&gt;</span> {
</span></span><span style=display:flex><span>                <span style=color:#6c7086;font-style:italic>$interp</span>.instruction_result <span style=color:#89dceb;font-weight:700>=</span> e;
</span></span><span style=display:flex><span>                <span style=color:#cba6f7>return</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    )<span style=color:#89dceb;font-weight:700>*</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The <code>memory_resize!</code> macro expands the memory if necessary. If the memory limit is reached, it will set the <code>InstructionResult::MemoryLimitOOG</code>. Additionally, it will calculate the extra gas of the memory expansion costs.</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rs data-lang=rs><span style=display:flex><span>macro_rules<span style=color:#89dceb;font-weight:700>!</span> memory_resize {
</span></span><span style=display:flex><span>    (<span style=color:#6c7086;font-style:italic>$interp</span>:<span style=color:#f9e2af>expr</span>, <span style=color:#6c7086;font-style:italic>$offset</span>:<span style=color:#f9e2af>expr</span>, <span style=color:#6c7086;font-style:italic>$len</span>:<span style=color:#f9e2af>expr</span>) <span style=color:#89dceb;font-weight:700>=&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#89b4fa>memory_resize!</span>(<span style=color:#6c7086;font-style:italic>$interp</span>, <span style=color:#6c7086;font-style:italic>$offset</span>, <span style=color:#6c7086;font-style:italic>$len</span>, ())
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>    (<span style=color:#6c7086;font-style:italic>$interp</span>:<span style=color:#f9e2af>expr</span>, <span style=color:#6c7086;font-style:italic>$offset</span>:<span style=color:#f9e2af>expr</span>, <span style=color:#6c7086;font-style:italic>$len</span>:<span style=color:#f9e2af>expr</span>, <span style=color:#6c7086;font-style:italic>$ret</span>:<span style=color:#f9e2af>expr</span>) <span style=color:#89dceb;font-weight:700>=&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#f38ba8>let</span> size <span style=color:#89dceb;font-weight:700>=</span> <span style=color:#6c7086;font-style:italic>$offset</span>.saturating_add(<span style=color:#6c7086;font-style:italic>$len</span>);
</span></span><span style=display:flex><span>        <span style=color:#cba6f7>if</span> size <span style=color:#89dceb;font-weight:700>&gt;</span> <span style=color:#6c7086;font-style:italic>$interp</span>.memory.len() {
</span></span><span style=display:flex><span>            <span style=color:#cba6f7>if</span> <span style=color:#6c7086;font-style:italic>$interp</span>.memory.limit_reached(size) {
</span></span><span style=display:flex><span>                <span style=color:#6c7086;font-style:italic>$interp</span>.instruction_result <span style=color:#89dceb;font-weight:700>=</span> InstructionResult::MemoryLimitOOG;
</span></span><span style=display:flex><span>                <span style=color:#cba6f7>return</span> <span style=color:#6c7086;font-style:italic>$ret</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#6c7086;font-style:italic>// We are fine with saturating to usize if size is close to MAX value.
</span></span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic></span>            <span style=color:#f38ba8>let</span> rounded_size <span style=color:#89dceb;font-weight:700>=</span> <span style=color:#cba6f7>crate</span>::interpreter::next_multiple_of_32(size);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#6c7086;font-style:italic>// Gas is calculated in EVM words (256bits).
</span></span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic></span>            <span style=color:#f38ba8>let</span> words_num <span style=color:#89dceb;font-weight:700>=</span> rounded_size <span style=color:#89dceb;font-weight:700>/</span> <span style=color:#fab387>32</span>;
</span></span><span style=display:flex><span>            <span style=color:#cba6f7>if</span> <span style=color:#89dceb;font-weight:700>!</span><span style=color:#6c7086;font-style:italic>$interp</span>.gas.record_memory(<span style=color:#cba6f7>crate</span>::gas::memory_gas(words_num)) {
</span></span><span style=display:flex><span>                <span style=color:#6c7086;font-style:italic>$interp</span>.instruction_result <span style=color:#89dceb;font-weight:700>=</span> InstructionResult::MemoryLimitOOG;
</span></span><span style=display:flex><span>                <span style=color:#cba6f7>return</span> <span style=color:#6c7086;font-style:italic>$ret</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#6c7086;font-style:italic>// Gas of memory expansion cost (not covered yet)
</span></span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic></span>            <span style=color:#6c7086;font-style:italic>$interp</span>.memory.resize(rounded_size);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>If the interpreter is supposed to be in view-only mode, the <code>check_staticcall!</code> macro will set the <code>InstructionResult::StateChangeStaticCall</code> and return.</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rs data-lang=rs><span style=display:flex><span>macro_rules<span style=color:#89dceb;font-weight:700>!</span> check_staticcall {
</span></span><span style=display:flex><span>    (<span style=color:#6c7086;font-style:italic>$interp</span>:<span style=color:#f9e2af>expr</span>) <span style=color:#89dceb;font-weight:700>=&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#cba6f7>if</span> <span style=color:#6c7086;font-style:italic>$interp</span>.is_static {
</span></span><span style=display:flex><span>            <span style=color:#6c7086;font-style:italic>$interp</span>.instruction_result <span style=color:#89dceb;font-weight:700>=</span> InstructionResult::StateChangeStaticCall;
</span></span><span style=display:flex><span>            <span style=color:#cba6f7>return</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Finally, <code>as_u64_saturated!</code> and <code>as_usize_or_fail!</code> macros are useful to convert inputs to <code>u64</code> (saturating to <code>u64::MAX</code> rather than overflowing) or <code>usize</code> (reverting if not possible).</p><hr><p>Now that the useful interpreter macros are understood, the following sections will delve into the implementation functions for various opcode instructions. In addition to the <a href=https://ethereum.github.io/yellowpaper/paper.pdf>yellow paper</a>, which provides a highly mathematical perspective, <a href=https://www.evm.codes>evm.codes</a> serves as a practical, and therefore, extremely useful resource. It offers not only comprehensive and clear explanations but also features a playground to thoroughly explore the behavior of arbitrary (user-input) bytecode and calldata.</p><p><em>Note: Instructions can be groupped in several ways. This article will follow <code>revm</code>&rsquo;s groupping criteria which is similar yellow paper, but more granular.</em></p><h3 id=arithmetic-instructions>Arithmetic Instructions<a hidden class=anchor aria-hidden=true href=#arithmetic-instructions>#</a></h3><p>The EVM has several opcodes to perform arithmetic operations based on different inputs previously loaded onto the stack.</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rs data-lang=rs><span style=display:flex><span><span style=color:#6c7086;font-style:italic>// Snippet of the `opcodes!` macro to showcase EVM&#39;s arithmetic opcodes,
</span></span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic>// their mnemonic representation, and their [`Instruction`].
</span></span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic></span><span style=color:#89b4fa>opcodes!</span> {
</span></span><span style=display:flex><span>    <span style=color:#fab387>0x01</span> <span style=color:#89dceb;font-weight:700>=&gt;</span> <span style=color:#f9e2af>ADD</span>        <span style=color:#89dceb;font-weight:700>=&gt;</span> arithmetic::wrapping_add,
</span></span><span style=display:flex><span>    <span style=color:#fab387>0x02</span> <span style=color:#89dceb;font-weight:700>=&gt;</span> <span style=color:#f9e2af>MUL</span>        <span style=color:#89dceb;font-weight:700>=&gt;</span> arithmetic::wrapping_mul,
</span></span><span style=display:flex><span>    <span style=color:#fab387>0x03</span> <span style=color:#89dceb;font-weight:700>=&gt;</span> <span style=color:#f9e2af>SUB</span>        <span style=color:#89dceb;font-weight:700>=&gt;</span> arithmetic::wrapping_sub,
</span></span><span style=display:flex><span>    <span style=color:#fab387>0x04</span> <span style=color:#89dceb;font-weight:700>=&gt;</span> <span style=color:#f9e2af>DIV</span>        <span style=color:#89dceb;font-weight:700>=&gt;</span> arithmetic::div,
</span></span><span style=display:flex><span>    <span style=color:#fab387>0x05</span> <span style=color:#89dceb;font-weight:700>=&gt;</span> <span style=color:#f9e2af>SDIV</span>       <span style=color:#89dceb;font-weight:700>=&gt;</span> arithmetic::sdiv,
</span></span><span style=display:flex><span>    <span style=color:#fab387>0x06</span> <span style=color:#89dceb;font-weight:700>=&gt;</span> <span style=color:#f9e2af>MOD</span>        <span style=color:#89dceb;font-weight:700>=&gt;</span> arithmetic::rem,
</span></span><span style=display:flex><span>    <span style=color:#fab387>0x07</span> <span style=color:#89dceb;font-weight:700>=&gt;</span> <span style=color:#f9e2af>SMOD</span>       <span style=color:#89dceb;font-weight:700>=&gt;</span> arithmetic::smod,
</span></span><span style=display:flex><span>    <span style=color:#fab387>0x08</span> <span style=color:#89dceb;font-weight:700>=&gt;</span> <span style=color:#f9e2af>ADDMOD</span>     <span style=color:#89dceb;font-weight:700>=&gt;</span> arithmetic::addmod,
</span></span><span style=display:flex><span>    <span style=color:#fab387>0x09</span> <span style=color:#89dceb;font-weight:700>=&gt;</span> <span style=color:#f9e2af>MULMOD</span>     <span style=color:#89dceb;font-weight:700>=&gt;</span> arithmetic::mulmod,
</span></span><span style=display:flex><span>    <span style=color:#fab387>0x0A</span> <span style=color:#89dceb;font-weight:700>=&gt;</span> <span style=color:#f9e2af>EXP</span>        <span style=color:#89dceb;font-weight:700>=&gt;</span> arithmetic::exp::<span style=color:#89dceb;font-weight:700>&lt;</span>H, <span style=color:#f9e2af>SPEC</span><span style=color:#89dceb;font-weight:700>&gt;</span>,
</span></span><span style=display:flex><span>    <span style=color:#fab387>0x0B</span> <span style=color:#89dceb;font-weight:700>=&gt;</span> <span style=color:#f9e2af>SIGNEXTEND</span> <span style=color:#89dceb;font-weight:700>=&gt;</span> arithmetic::signextend,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>As explained in the <a href=../revm-pt1>previous article</a>, <code>revm</code> is built on <a href=https://github.com/recmo/uint>ruint</a> primitive types. Thanks to this foundation, the implementation of arithmetic instructions is trivial, as it relies on the built-in methods of the <code>U256</code> type defined in the imported crate. Because of this, we will focus solely on the implementation of the <code>ADD</code> opcode.</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rs data-lang=rs><span style=display:flex><span><span style=color:#cba6f7>pub</span> <span style=color:#cba6f7>fn</span> <span style=color:#89b4fa>wrapping_add</span><span style=color:#89dceb;font-weight:700>&lt;</span>H: <span style=color:#f9e2af>Host</span><span style=color:#89dceb;font-weight:700>&gt;</span>(interpreter: <span style=color:#cba6f7>&amp;</span><span style=color:#f9e2af>mut</span> Interpreter, _host: <span style=color:#cba6f7>&amp;</span><span style=color:#f9e2af>mut</span> H) {
</span></span><span style=display:flex><span>    <span style=color:#89b4fa>gas!</span>(interpreter, gas::<span style=color:#f9e2af>VERYLOW</span>);
</span></span><span style=display:flex><span>    <span style=color:#89b4fa>pop_top!</span>(interpreter, op1, op2);
</span></span><span style=display:flex><span>    <span style=color:#89dceb;font-weight:700>*</span>op2 <span style=color:#89dceb;font-weight:700>=</span> op1.wrapping_add(<span style=color:#89dceb;font-weight:700>*</span>op2);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>As previously mentioned in the <a href=./#useful-macros>useful macros section</a>, the <code>gas!</code> macro will record the gas cost associated with the computation of the instruction. Then, the <code>pop_top!</code> macro pops up to 2 words and returns a reference to the new top-most item on the stack. <code>fn wrapping_add()</code> leverages this macro to seamlessly dereference the second stack input and update its value with the result of the arithmetic operation. Note that this process is equivalent to popping the words from the stack, adding them together, and then pushing the result back onto the stack. Nevertheless, by using the <code>pop_top!</code> macro, this operation can be executed more concisely and efficiently.</p><h3 id=bitwise-instructions>Bitwise Instructions<a hidden class=anchor aria-hidden=true href=#bitwise-instructions>#</a></h3><p>The EVM has several opcodes to perform bitwise operations based on different inputs previously loaded onto the stack.</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rs data-lang=rs><span style=display:flex><span><span style=color:#6c7086;font-style:italic>// Snippet of the `opcodes!` macro to showcase EVM&#39;s bitwise opcodes,
</span></span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic>// their mnemonic representation, and their [`Instruction`].
</span></span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic></span><span style=color:#89b4fa>opcodes!</span> {
</span></span><span style=display:flex><span>    <span style=color:#fab387>0x10</span> <span style=color:#89dceb;font-weight:700>=&gt;</span> <span style=color:#f9e2af>LT</span>     <span style=color:#89dceb;font-weight:700>=&gt;</span> bitwise::lt,
</span></span><span style=display:flex><span>    <span style=color:#fab387>0x11</span> <span style=color:#89dceb;font-weight:700>=&gt;</span> <span style=color:#f9e2af>GT</span>     <span style=color:#89dceb;font-weight:700>=&gt;</span> bitwise::gt,
</span></span><span style=display:flex><span>    <span style=color:#fab387>0x12</span> <span style=color:#89dceb;font-weight:700>=&gt;</span> <span style=color:#f9e2af>SLT</span>    <span style=color:#89dceb;font-weight:700>=&gt;</span> bitwise::slt,
</span></span><span style=display:flex><span>    <span style=color:#fab387>0x13</span> <span style=color:#89dceb;font-weight:700>=&gt;</span> <span style=color:#f9e2af>SGT</span>    <span style=color:#89dceb;font-weight:700>=&gt;</span> bitwise::sgt,
</span></span><span style=display:flex><span>    <span style=color:#fab387>0x14</span> <span style=color:#89dceb;font-weight:700>=&gt;</span> <span style=color:#f9e2af>EQ</span>     <span style=color:#89dceb;font-weight:700>=&gt;</span> bitwise::eq,
</span></span><span style=display:flex><span>    <span style=color:#fab387>0x15</span> <span style=color:#89dceb;font-weight:700>=&gt;</span> <span style=color:#f9e2af>ISZERO</span> <span style=color:#89dceb;font-weight:700>=&gt;</span> bitwise::iszero,
</span></span><span style=display:flex><span>    <span style=color:#fab387>0x16</span> <span style=color:#89dceb;font-weight:700>=&gt;</span> <span style=color:#f9e2af>AND</span>    <span style=color:#89dceb;font-weight:700>=&gt;</span> bitwise::bitand,
</span></span><span style=display:flex><span>    <span style=color:#fab387>0x17</span> <span style=color:#89dceb;font-weight:700>=&gt;</span> <span style=color:#f9e2af>OR</span>     <span style=color:#89dceb;font-weight:700>=&gt;</span> bitwise::bitor,
</span></span><span style=display:flex><span>    <span style=color:#fab387>0x18</span> <span style=color:#89dceb;font-weight:700>=&gt;</span> <span style=color:#f9e2af>XOR</span>    <span style=color:#89dceb;font-weight:700>=&gt;</span> bitwise::bitxor,
</span></span><span style=display:flex><span>    <span style=color:#fab387>0x19</span> <span style=color:#89dceb;font-weight:700>=&gt;</span> <span style=color:#f9e2af>NOT</span>    <span style=color:#89dceb;font-weight:700>=&gt;</span> bitwise::not,
</span></span><span style=display:flex><span>    <span style=color:#fab387>0x1A</span> <span style=color:#89dceb;font-weight:700>=&gt;</span> <span style=color:#f9e2af>BYTE</span>   <span style=color:#89dceb;font-weight:700>=&gt;</span> bitwise::byte,
</span></span><span style=display:flex><span>    <span style=color:#fab387>0x1B</span> <span style=color:#89dceb;font-weight:700>=&gt;</span> <span style=color:#f9e2af>SHL</span>    <span style=color:#89dceb;font-weight:700>=&gt;</span> bitwise::shl::<span style=color:#89dceb;font-weight:700>&lt;</span>H, <span style=color:#f9e2af>SPEC</span><span style=color:#89dceb;font-weight:700>&gt;</span>,
</span></span><span style=display:flex><span>    <span style=color:#fab387>0x1C</span> <span style=color:#89dceb;font-weight:700>=&gt;</span> <span style=color:#f9e2af>SHR</span>    <span style=color:#89dceb;font-weight:700>=&gt;</span> bitwise::shr::<span style=color:#89dceb;font-weight:700>&lt;</span>H, <span style=color:#f9e2af>SPEC</span><span style=color:#89dceb;font-weight:700>&gt;</span>,
</span></span><span style=display:flex><span>    <span style=color:#fab387>0x1D</span> <span style=color:#89dceb;font-weight:700>=&gt;</span> <span style=color:#f9e2af>SAR</span>    <span style=color:#89dceb;font-weight:700>=&gt;</span> bitwise::sar::<span style=color:#89dceb;font-weight:700>&lt;</span>H, <span style=color:#f9e2af>SPEC</span><span style=color:#89dceb;font-weight:700>&gt;</span>,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This block of instructions is also trivial to implement thanks to the built-in methods of the <code>U256</code> type. Bitwise operations can be split into two categories: bit-comparison operations, which return <code>true</code> or <code>false</code>, and bit-modifying operations. However, since the EVM uses U256 for all values, these boolean outcomes are represented as <code>U256::from(1)</code> (true) or <code>U256::from(0)</code> (false).</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rs data-lang=rs><span style=display:flex><span><span style=color:#cba6f7>pub</span> <span style=color:#cba6f7>fn</span> <span style=color:#89b4fa>eq</span><span style=color:#89dceb;font-weight:700>&lt;</span>H: <span style=color:#f9e2af>Host</span><span style=color:#89dceb;font-weight:700>&gt;</span>(interpreter: <span style=color:#cba6f7>&amp;</span><span style=color:#f9e2af>mut</span> Interpreter, _host: <span style=color:#cba6f7>&amp;</span><span style=color:#f9e2af>mut</span> H) {
</span></span><span style=display:flex><span>    <span style=color:#89b4fa>gas!</span>(interpreter, gas::<span style=color:#f9e2af>VERYLOW</span>);
</span></span><span style=display:flex><span>    <span style=color:#89b4fa>pop_top!</span>(interpreter, op1, op2);
</span></span><span style=display:flex><span>    <span style=color:#89dceb;font-weight:700>*</span>op2 <span style=color:#89dceb;font-weight:700>=</span> U256::from(op1 <span style=color:#89dceb;font-weight:700>==</span> <span style=color:#89dceb;font-weight:700>*</span>op2);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#cba6f7>pub</span> <span style=color:#cba6f7>fn</span> <span style=color:#89b4fa>bitand</span><span style=color:#89dceb;font-weight:700>&lt;</span>H: <span style=color:#f9e2af>Host</span><span style=color:#89dceb;font-weight:700>&gt;</span>(interpreter: <span style=color:#cba6f7>&amp;</span><span style=color:#f9e2af>mut</span> Interpreter, _host: <span style=color:#cba6f7>&amp;</span><span style=color:#f9e2af>mut</span> H) {
</span></span><span style=display:flex><span>    <span style=color:#89b4fa>gas!</span>(interpreter, gas::<span style=color:#f9e2af>VERYLOW</span>);
</span></span><span style=display:flex><span>    <span style=color:#89b4fa>pop_top!</span>(interpreter, op1, op2);
</span></span><span style=display:flex><span>    <span style=color:#89dceb;font-weight:700>*</span>op2 <span style=color:#89dceb;font-weight:700>=</span> op1 <span style=color:#89dceb;font-weight:700>&amp;</span> <span style=color:#89dceb;font-weight:700>*</span>op2;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Bitwise operations follow the same approach as <a href=./#arithmetic-instructions>arithmetic operations</a>, using the <code>gas!</code> and <code>pop_top!</code> macros to update the gas cost associated with the ongoing interpreter execution and to modify the stack accordingly.</p><h3 id=environment-instructions>Environment Instructions<a hidden class=anchor aria-hidden=true href=#environment-instructions>#</a></h3><p>Environment instructions refer to those operations that are related to information stored on the <code>Env</code> struct, which the interpreter can access via the <code>fn env()</code> method of the <code>Host</code> trait.</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rs data-lang=rs><span style=display:flex><span><span style=color:#6c7086;font-style:italic>// Snippet of the `opcodes!` macro to showcase environment opcodes,
</span></span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic>// their mnemonic representation, and their [`Instruction`].
</span></span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic></span><span style=color:#89b4fa>opcodes!</span> {
</span></span><span style=display:flex><span>    <span style=color:#fab387>0x32</span> <span style=color:#89dceb;font-weight:700>=&gt;</span> <span style=color:#f9e2af>ORIGIN</span>      <span style=color:#89dceb;font-weight:700>=&gt;</span> host_env::origin,
</span></span><span style=display:flex><span>    <span style=color:#fab387>0x3A</span> <span style=color:#89dceb;font-weight:700>=&gt;</span> <span style=color:#f9e2af>GASPRICE</span>    <span style=color:#89dceb;font-weight:700>=&gt;</span> host_env::gasprice,
</span></span><span style=display:flex><span>    <span style=color:#fab387>0x41</span> <span style=color:#89dceb;font-weight:700>=&gt;</span> <span style=color:#f9e2af>COINBASE</span>    <span style=color:#89dceb;font-weight:700>=&gt;</span> host_env::coinbase,
</span></span><span style=display:flex><span>    <span style=color:#fab387>0x42</span> <span style=color:#89dceb;font-weight:700>=&gt;</span> <span style=color:#f9e2af>TIMESTAMP</span>   <span style=color:#89dceb;font-weight:700>=&gt;</span> host_env::timestamp,
</span></span><span style=display:flex><span>    <span style=color:#fab387>0x43</span> <span style=color:#89dceb;font-weight:700>=&gt;</span> <span style=color:#f9e2af>NUMBER</span>      <span style=color:#89dceb;font-weight:700>=&gt;</span> host_env::number,
</span></span><span style=display:flex><span>    <span style=color:#fab387>0x44</span> <span style=color:#89dceb;font-weight:700>=&gt;</span> <span style=color:#f9e2af>DIFFICULTY</span>  <span style=color:#89dceb;font-weight:700>=&gt;</span> host_env::difficulty::<span style=color:#89dceb;font-weight:700>&lt;</span>H, <span style=color:#f9e2af>SPEC</span><span style=color:#89dceb;font-weight:700>&gt;</span>,
</span></span><span style=display:flex><span>    <span style=color:#fab387>0x45</span> <span style=color:#89dceb;font-weight:700>=&gt;</span> <span style=color:#f9e2af>GASLIMIT</span>    <span style=color:#89dceb;font-weight:700>=&gt;</span> host_env::gaslimit,
</span></span><span style=display:flex><span>    <span style=color:#fab387>0x46</span> <span style=color:#89dceb;font-weight:700>=&gt;</span> <span style=color:#f9e2af>CHAINID</span>     <span style=color:#89dceb;font-weight:700>=&gt;</span> host_env::chainid::<span style=color:#89dceb;font-weight:700>&lt;</span>H, <span style=color:#f9e2af>SPEC</span><span style=color:#89dceb;font-weight:700>&gt;</span>,
</span></span><span style=display:flex><span>    <span style=color:#fab387>0x48</span> <span style=color:#89dceb;font-weight:700>=&gt;</span> <span style=color:#f9e2af>BASEFEE</span>     <span style=color:#89dceb;font-weight:700>=&gt;</span> host_env::basefee::<span style=color:#89dceb;font-weight:700>&lt;</span>H, <span style=color:#f9e2af>SPEC</span><span style=color:#89dceb;font-weight:700>&gt;</span>,
</span></span><span style=display:flex><span>    <span style=color:#fab387>0x49</span> <span style=color:#89dceb;font-weight:700>=&gt;</span> <span style=color:#f9e2af>BLOBHASH</span>    <span style=color:#89dceb;font-weight:700>=&gt;</span> host_env::blob_hash::<span style=color:#89dceb;font-weight:700>&lt;</span>H, <span style=color:#f9e2af>SPEC</span><span style=color:#89dceb;font-weight:700>&gt;</span>,
</span></span><span style=display:flex><span>    <span style=color:#fab387>0x4A</span> <span style=color:#89dceb;font-weight:700>=&gt;</span> <span style=color:#f9e2af>BLOBBASEFEE</span> <span style=color:#89dceb;font-weight:700>=&gt;</span> host_env::blob_basefee::<span style=color:#89dceb;font-weight:700>&lt;</span>H, <span style=color:#f9e2af>SPEC</span><span style=color:#89dceb;font-weight:700>&gt;</span>,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This block of instructions is also trivial to implement, as it simply pushes new environmental information (which is easily accessible thanks to the <code>Host</code> trait) onto the stack. The instructions simply call the <code>gas!</code> and <code>push!</code> macros to update the gas cost associated with the ongoing interpreter execution and to modify its stack accordingly.</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rs data-lang=rs><span style=display:flex><span><span style=color:#cba6f7>pub</span> <span style=color:#cba6f7>fn</span> <span style=color:#89b4fa>origin</span><span style=color:#89dceb;font-weight:700>&lt;</span>H: <span style=color:#f9e2af>Host</span><span style=color:#89dceb;font-weight:700>&gt;</span>(interpreter: <span style=color:#cba6f7>&amp;</span><span style=color:#f9e2af>mut</span> Interpreter, host: <span style=color:#cba6f7>&amp;</span><span style=color:#f9e2af>mut</span> H) {
</span></span><span style=display:flex><span>    <span style=color:#89b4fa>gas!</span>(interpreter, gas::<span style=color:#f9e2af>BASE</span>);
</span></span><span style=display:flex><span>    <span style=color:#89b4fa>push_b256!</span>(interpreter, host.env().tx.caller.into_word());
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#cba6f7>pub</span> <span style=color:#cba6f7>fn</span> <span style=color:#89b4fa>timestamp</span><span style=color:#89dceb;font-weight:700>&lt;</span>H: <span style=color:#f9e2af>Host</span><span style=color:#89dceb;font-weight:700>&gt;</span>(interpreter: <span style=color:#cba6f7>&amp;</span><span style=color:#f9e2af>mut</span> Interpreter, host: <span style=color:#cba6f7>&amp;</span><span style=color:#f9e2af>mut</span> H) {
</span></span><span style=display:flex><span>    <span style=color:#89b4fa>gas!</span>(interpreter, gas::<span style=color:#f9e2af>BASE</span>);
</span></span><span style=display:flex><span>    <span style=color:#89b4fa>push!</span>(interpreter, host.env().block.timestamp);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=system-instructions>System Instructions<a hidden class=anchor aria-hidden=true href=#system-instructions>#</a></h3><p>System instructions refer to operations related to information in the <code>Interpreter</code> struct, excluding <code>Memory</code> and <code>Stack</code> operations, which have their own set of opcodes.</p><p>Instructions <code>0x30..0x39</code> relate to <code>Contract</code> information, whereas instruction <code>0x5A</code> relates to <code>Gas</code> costs.</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rs data-lang=rs><span style=display:flex><span><span style=color:#6c7086;font-style:italic>// Snippet of the `opcodes!` macro to showcase EVM&#39;s system opcodes,
</span></span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic>// their mnemonic representation, and their [`Instruction`].
</span></span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic></span><span style=color:#89b4fa>opcodes!</span> {
</span></span><span style=display:flex><span>    <span style=color:#fab387>0x30</span> <span style=color:#89dceb;font-weight:700>=&gt;</span> <span style=color:#f9e2af>ADDRESS</span>        <span style=color:#89dceb;font-weight:700>=&gt;</span> system::address,
</span></span><span style=display:flex><span>    <span style=color:#fab387>0x33</span> <span style=color:#89dceb;font-weight:700>=&gt;</span> <span style=color:#f9e2af>CALLER</span>         <span style=color:#89dceb;font-weight:700>=&gt;</span> system::caller,
</span></span><span style=display:flex><span>    <span style=color:#fab387>0x34</span> <span style=color:#89dceb;font-weight:700>=&gt;</span> <span style=color:#f9e2af>CALLVALUE</span>      <span style=color:#89dceb;font-weight:700>=&gt;</span> system::callvalue,
</span></span><span style=display:flex><span>    <span style=color:#fab387>0x35</span> <span style=color:#89dceb;font-weight:700>=&gt;</span> <span style=color:#f9e2af>CALLDATALOAD</span>   <span style=color:#89dceb;font-weight:700>=&gt;</span> system::calldataload,
</span></span><span style=display:flex><span>    <span style=color:#fab387>0x36</span> <span style=color:#89dceb;font-weight:700>=&gt;</span> <span style=color:#f9e2af>CALLDATASIZE</span>   <span style=color:#89dceb;font-weight:700>=&gt;</span> system::calldatasize,
</span></span><span style=display:flex><span>    <span style=color:#fab387>0x37</span> <span style=color:#89dceb;font-weight:700>=&gt;</span> <span style=color:#f9e2af>CALLDATACOPY</span>   <span style=color:#89dceb;font-weight:700>=&gt;</span> system::calldatacopy,
</span></span><span style=display:flex><span>    <span style=color:#fab387>0x38</span> <span style=color:#89dceb;font-weight:700>=&gt;</span> <span style=color:#f9e2af>CODESIZE</span>       <span style=color:#89dceb;font-weight:700>=&gt;</span> system::codesize,
</span></span><span style=display:flex><span>    <span style=color:#fab387>0x39</span> <span style=color:#89dceb;font-weight:700>=&gt;</span> <span style=color:#f9e2af>CODECOPY</span>       <span style=color:#89dceb;font-weight:700>=&gt;</span> system::codecopy,
</span></span><span style=display:flex><span>    <span style=color:#fab387>0x5A</span> <span style=color:#89dceb;font-weight:700>=&gt;</span> <span style=color:#f9e2af>GAS</span>            <span style=color:#89dceb;font-weight:700>=&gt;</span> system::gas,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Firstly, the simplest opcodes will simply push new information into the stack.</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rs data-lang=rs><span style=display:flex><span><span style=color:#6c7086;font-style:italic>// Push the address of the [`Contract`] address onto the stack.
</span></span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic></span><span style=color:#cba6f7>pub</span> <span style=color:#cba6f7>fn</span> <span style=color:#89b4fa>address</span><span style=color:#89dceb;font-weight:700>&lt;</span>H: <span style=color:#f9e2af>Host</span><span style=color:#89dceb;font-weight:700>&gt;</span>(interpreter: <span style=color:#cba6f7>&amp;</span><span style=color:#f9e2af>mut</span> Interpreter, _host: <span style=color:#cba6f7>&amp;</span><span style=color:#f9e2af>mut</span> H) {
</span></span><span style=display:flex><span>    <span style=color:#89b4fa>gas!</span>(interpreter, gas::<span style=color:#f9e2af>BASE</span>);
</span></span><span style=display:flex><span>    <span style=color:#89b4fa>push_b256!</span>(interpreter, interpreter.contract.address.into_word());
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic>// Push the address of the [`Contract`] caller onto the stack.
</span></span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic></span><span style=color:#cba6f7>pub</span> <span style=color:#cba6f7>fn</span> <span style=color:#89b4fa>caller</span><span style=color:#89dceb;font-weight:700>&lt;</span>H: <span style=color:#f9e2af>Host</span><span style=color:#89dceb;font-weight:700>&gt;</span>(interpreter: <span style=color:#cba6f7>&amp;</span><span style=color:#f9e2af>mut</span> Interpreter, _host: <span style=color:#cba6f7>&amp;</span><span style=color:#f9e2af>mut</span> H) {
</span></span><span style=display:flex><span>    <span style=color:#89b4fa>gas!</span>(interpreter, gas::<span style=color:#f9e2af>BASE</span>);
</span></span><span style=display:flex><span>    <span style=color:#89b4fa>push_b256!</span>(interpreter, interpreter.contract.caller.into_word());
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic>// Push the value of the [`Contract`] call onto the stack.
</span></span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic></span><span style=color:#cba6f7>pub</span> <span style=color:#cba6f7>fn</span> <span style=color:#89b4fa>callvalue</span><span style=color:#89dceb;font-weight:700>&lt;</span>H: <span style=color:#f9e2af>Host</span><span style=color:#89dceb;font-weight:700>&gt;</span>(interpreter: <span style=color:#cba6f7>&amp;</span><span style=color:#f9e2af>mut</span> Interpreter, _host: <span style=color:#cba6f7>&amp;</span><span style=color:#f9e2af>mut</span> H) {
</span></span><span style=display:flex><span>    <span style=color:#89b4fa>gas!</span>(interpreter, gas::<span style=color:#f9e2af>BASE</span>);
</span></span><span style=display:flex><span>    <span style=color:#89b4fa>push!</span>(interpreter, interpreter.contract.value);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic>// Push the size of the [`Contract`] calldata onto the stack.
</span></span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic></span><span style=color:#cba6f7>pub</span> <span style=color:#cba6f7>fn</span> <span style=color:#89b4fa>calldatasize</span><span style=color:#89dceb;font-weight:700>&lt;</span>H: <span style=color:#f9e2af>Host</span><span style=color:#89dceb;font-weight:700>&gt;</span>(interpreter: <span style=color:#cba6f7>&amp;</span><span style=color:#f9e2af>mut</span> Interpreter, _host: <span style=color:#cba6f7>&amp;</span><span style=color:#f9e2af>mut</span> H) {
</span></span><span style=display:flex><span>    <span style=color:#89b4fa>gas!</span>(interpreter, gas::<span style=color:#f9e2af>BASE</span>);
</span></span><span style=display:flex><span>    <span style=color:#89b4fa>push!</span>(interpreter, U256::from(interpreter.contract.input.len()));
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic>// Push the size of the [`Contract`] code onto the stack.
</span></span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic></span><span style=color:#cba6f7>pub</span> <span style=color:#cba6f7>fn</span> <span style=color:#89b4fa>codesize</span><span style=color:#89dceb;font-weight:700>&lt;</span>H: <span style=color:#f9e2af>Host</span><span style=color:#89dceb;font-weight:700>&gt;</span>(interpreter: <span style=color:#cba6f7>&amp;</span><span style=color:#f9e2af>mut</span> Interpreter, _host: <span style=color:#cba6f7>&amp;</span><span style=color:#f9e2af>mut</span> H) {
</span></span><span style=display:flex><span>    <span style=color:#89b4fa>gas!</span>(interpreter, gas::<span style=color:#f9e2af>BASE</span>);
</span></span><span style=display:flex><span>    <span style=color:#89b4fa>push!</span>(interpreter, U256::from(interpreter.contract.bytecode.len()));
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic>// Push the remaining [`Gas`] value onto the stack.
</span></span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic></span><span style=color:#cba6f7>pub</span> <span style=color:#cba6f7>fn</span> <span style=color:#89b4fa>gas</span><span style=color:#89dceb;font-weight:700>&lt;</span>H: <span style=color:#f9e2af>Host</span><span style=color:#89dceb;font-weight:700>&gt;</span>(interpreter: <span style=color:#cba6f7>&amp;</span><span style=color:#f9e2af>mut</span> Interpreter, _host: <span style=color:#cba6f7>&amp;</span><span style=color:#f9e2af>mut</span> H) {
</span></span><span style=display:flex><span>    <span style=color:#89b4fa>gas!</span>(interpreter, gas::<span style=color:#f9e2af>BASE</span>);
</span></span><span style=display:flex><span>    <span style=color:#89b4fa>push!</span>(interpreter, U256::from(interpreter.gas.remaining()));
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Secondly, <code>CALLDATALOAD</code> opcodes will take an input from the stack (offset) and 32-bytes of calldata (starting from the offset) into the stack. If the offset is bigger than the calldata length, a zero will be pushed.</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rs data-lang=rs><span style=display:flex><span><span style=color:#6c7086;font-style:italic>// Push 1 word of call data into the stack. Load from `index` (offfset).
</span></span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic></span><span style=color:#cba6f7>pub</span> <span style=color:#cba6f7>fn</span> <span style=color:#89b4fa>calldataload</span><span style=color:#89dceb;font-weight:700>&lt;</span>H: <span style=color:#f9e2af>Host</span><span style=color:#89dceb;font-weight:700>&gt;</span>(interpreter: <span style=color:#cba6f7>&amp;</span><span style=color:#f9e2af>mut</span> Interpreter, _host: <span style=color:#cba6f7>&amp;</span><span style=color:#f9e2af>mut</span> H) {
</span></span><span style=display:flex><span>    <span style=color:#89b4fa>gas!</span>(interpreter, gas::<span style=color:#f9e2af>VERYLOW</span>);
</span></span><span style=display:flex><span>    <span style=color:#89b4fa>pop!</span>(interpreter, index);
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>let</span> index <span style=color:#89dceb;font-weight:700>=</span> <span style=color:#89b4fa>as_usize_saturated!</span>(index);
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>let</span> load <span style=color:#89dceb;font-weight:700>=</span> <span style=color:#cba6f7>if</span> index <span style=color:#89dceb;font-weight:700>&lt;</span> interpreter.contract.input.len() {
</span></span><span style=display:flex><span>        <span style=color:#f38ba8>let</span> length <span style=color:#89dceb;font-weight:700>=</span> <span style=color:#fab387>32.</span>min(interpreter.contract.input.len() <span style=color:#89dceb;font-weight:700>-</span> index);
</span></span><span style=display:flex><span>        <span style=color:#f38ba8>let</span> end <span style=color:#89dceb;font-weight:700>=</span> index <span style=color:#89dceb;font-weight:700>+</span> length;
</span></span><span style=display:flex><span>        <span style=color:#f38ba8>let</span> <span style=color:#cba6f7>mut</span> bytes <span style=color:#89dceb;font-weight:700>=</span> [<span style=color:#fab387>0</span><span style=color:#cba6f7>u8</span>; <span style=color:#fab387>32</span>];
</span></span><span style=display:flex><span>        bytes[<span style=color:#89dceb;font-weight:700>..</span>length].copy_from_slice(<span style=color:#89dceb;font-weight:700>&amp;</span>interpreter.contract.input[index<span style=color:#89dceb;font-weight:700>..</span>end]);
</span></span><span style=display:flex><span>        B256::new(bytes)
</span></span><span style=display:flex><span>    } <span style=color:#cba6f7>else</span> {
</span></span><span style=display:flex><span>        B256::<span style=color:#f9e2af>ZERO</span>
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#89b4fa>push_b256!</span>(interpreter, load);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Finally, <code>COPY</code> opcodes will take 3 inputs from the stack (memory offset, input data offset, and copy length) and store the corresponding data into memory. Note that it may be necessary to resize memory if the destination of the copied data requires to do so.</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rs data-lang=rs><span style=display:flex><span><span style=color:#cba6f7>pub</span> <span style=color:#cba6f7>fn</span> <span style=color:#89b4fa>calldatacopy</span><span style=color:#89dceb;font-weight:700>&lt;</span>H: <span style=color:#f9e2af>Host</span><span style=color:#89dceb;font-weight:700>&gt;</span>(interpreter: <span style=color:#cba6f7>&amp;</span><span style=color:#f9e2af>mut</span> Interpreter, _host: <span style=color:#cba6f7>&amp;</span><span style=color:#f9e2af>mut</span> H) {
</span></span><span style=display:flex><span>    <span style=color:#89b4fa>pop!</span>(interpreter, memory_offset, data_offset, len);
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>let</span> len <span style=color:#89dceb;font-weight:700>=</span> <span style=color:#89b4fa>as_usize_or_fail!</span>(interpreter, len);
</span></span><span style=display:flex><span>    <span style=color:#89b4fa>gas_or_fail!</span>(interpreter, gas::verylowcopy_cost(len <span style=color:#cba6f7>as</span> <span style=color:#f38ba8>u64</span>));
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>if</span> len <span style=color:#89dceb;font-weight:700>==</span> <span style=color:#fab387>0</span> {
</span></span><span style=display:flex><span>        <span style=color:#cba6f7>return</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>let</span> memory_offset <span style=color:#89dceb;font-weight:700>=</span> <span style=color:#89b4fa>as_usize_or_fail!</span>(interpreter, memory_offset);
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>let</span> data_offset <span style=color:#89dceb;font-weight:700>=</span> <span style=color:#89b4fa>as_usize_saturated!</span>(data_offset);
</span></span><span style=display:flex><span>    <span style=color:#89b4fa>memory_resize!</span>(interpreter, memory_offset, len);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6c7086;font-style:italic>// Can&#39;t panic because memory is resized beforehand.
</span></span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic></span>    interpreter.memory.set_data(
</span></span><span style=display:flex><span>        memory_offset,
</span></span><span style=display:flex><span>        data_offset,
</span></span><span style=display:flex><span>        len,
</span></span><span style=display:flex><span>        <span style=color:#89dceb;font-weight:700>&amp;</span>interpreter.contract.input,
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span><span style=color:#cba6f7>pub</span> <span style=color:#cba6f7>fn</span> <span style=color:#89b4fa>codecopy</span><span style=color:#89dceb;font-weight:700>&lt;</span>H: <span style=color:#f9e2af>Host</span><span style=color:#89dceb;font-weight:700>&gt;</span>(interpreter: <span style=color:#cba6f7>&amp;</span><span style=color:#f9e2af>mut</span> Interpreter, _host: <span style=color:#cba6f7>&amp;</span><span style=color:#f9e2af>mut</span> H) {
</span></span><span style=display:flex><span>    <span style=color:#89b4fa>pop!</span>(interpreter, memory_offset, code_offset, len);
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>let</span> len <span style=color:#89dceb;font-weight:700>=</span> <span style=color:#89b4fa>as_usize_or_fail!</span>(interpreter, len);
</span></span><span style=display:flex><span>    <span style=color:#89b4fa>gas_or_fail!</span>(interpreter, gas::verylowcopy_cost(len <span style=color:#cba6f7>as</span> <span style=color:#f38ba8>u64</span>));
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>if</span> len <span style=color:#89dceb;font-weight:700>==</span> <span style=color:#fab387>0</span> {
</span></span><span style=display:flex><span>        <span style=color:#cba6f7>return</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>let</span> memory_offset <span style=color:#89dceb;font-weight:700>=</span> <span style=color:#89b4fa>as_usize_or_fail!</span>(interpreter, memory_offset);
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>let</span> code_offset <span style=color:#89dceb;font-weight:700>=</span> <span style=color:#89b4fa>as_usize_saturated!</span>(code_offset);
</span></span><span style=display:flex><span>    <span style=color:#89b4fa>memory_resize!</span>(interpreter, memory_offset, len);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6c7086;font-style:italic>// Can&#39;t panic because memory is resized beforehand.
</span></span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic></span>    interpreter.memory.set_data(
</span></span><span style=display:flex><span>        memory_offset,
</span></span><span style=display:flex><span>        code_offset,
</span></span><span style=display:flex><span>        len,
</span></span><span style=display:flex><span>        interpreter.contract.bytecode.original_bytecode_slice(),
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=stack-instructions>Stack Instructions<a hidden class=anchor aria-hidden=true href=#stack-instructions>#</a></h3><p>Stack instructions refer to those operations that are solely related to stack manipulation. As such, they only require of interaction with the <code>Stack</code> struct of the interpreter.</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rs data-lang=rs><span style=display:flex><span><span style=color:#6c7086;font-style:italic>// Snippet of the `opcodes!` macro to showcase stack opcodes,
</span></span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic>// their mnemonic representation, and their [`Instruction`].
</span></span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic></span><span style=color:#89b4fa>opcodes!</span> {
</span></span><span style=display:flex><span>    <span style=color:#fab387>0x50</span> <span style=color:#89dceb;font-weight:700>=&gt;</span> <span style=color:#f9e2af>POP</span>      <span style=color:#89dceb;font-weight:700>=&gt;</span> stack::pop,
</span></span><span style=display:flex><span>    <span style=color:#fab387>0x5F</span> <span style=color:#89dceb;font-weight:700>=&gt;</span> <span style=color:#f9e2af>PUSH0</span>  <span style=color:#89dceb;font-weight:700>=&gt;</span> stack::push0::<span style=color:#89dceb;font-weight:700>&lt;</span>H, <span style=color:#f9e2af>SPEC</span><span style=color:#89dceb;font-weight:700>&gt;</span>,
</span></span><span style=display:flex><span>    <span style=color:#6c7086;font-style:italic>// PUSH (1..32)
</span></span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic></span>    <span style=color:#fab387>0x60</span> <span style=color:#89dceb;font-weight:700>=&gt;</span> <span style=color:#f9e2af>PUSH1</span>  <span style=color:#89dceb;font-weight:700>=&gt;</span> stack::push::<span style=color:#89dceb;font-weight:700>&lt;</span><span style=color:#fab387>1</span>, H<span style=color:#89dceb;font-weight:700>&gt;</span>,
</span></span><span style=display:flex><span>    <span style=color:#fab387>0x7F</span> <span style=color:#89dceb;font-weight:700>=&gt;</span> <span style=color:#f9e2af>PUSH32</span> <span style=color:#89dceb;font-weight:700>=&gt;</span> stack::push::<span style=color:#89dceb;font-weight:700>&lt;</span><span style=color:#fab387>32</span>, H<span style=color:#89dceb;font-weight:700>&gt;</span>,
</span></span><span style=display:flex><span>    <span style=color:#6c7086;font-style:italic>// DUP (1..16)
</span></span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic></span>    <span style=color:#fab387>0x80</span> <span style=color:#89dceb;font-weight:700>=&gt;</span> <span style=color:#f9e2af>DUP1</span>  <span style=color:#89dceb;font-weight:700>=&gt;</span> stack::dup::<span style=color:#89dceb;font-weight:700>&lt;</span><span style=color:#fab387>1</span>, H<span style=color:#89dceb;font-weight:700>&gt;</span>,
</span></span><span style=display:flex><span>    <span style=color:#fab387>0x8F</span> <span style=color:#89dceb;font-weight:700>=&gt;</span> <span style=color:#f9e2af>DUP16</span> <span style=color:#89dceb;font-weight:700>=&gt;</span> stack::dup::<span style=color:#89dceb;font-weight:700>&lt;</span><span style=color:#fab387>16</span>, H<span style=color:#89dceb;font-weight:700>&gt;</span>,
</span></span><span style=display:flex><span>    <span style=color:#6c7086;font-style:italic>// SWAP (1..16)
</span></span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic></span>    <span style=color:#fab387>0x90</span> <span style=color:#89dceb;font-weight:700>=&gt;</span> <span style=color:#f9e2af>SWAP1</span>  <span style=color:#89dceb;font-weight:700>=&gt;</span> stack::swap::<span style=color:#89dceb;font-weight:700>&lt;</span><span style=color:#fab387>1</span>, H<span style=color:#89dceb;font-weight:700>&gt;</span>,
</span></span><span style=display:flex><span>    <span style=color:#fab387>0x9F</span> <span style=color:#89dceb;font-weight:700>=&gt;</span> <span style=color:#f9e2af>SWAP16</span> <span style=color:#89dceb;font-weight:700>=&gt;</span> stack::swap::<span style=color:#89dceb;font-weight:700>&lt;</span><span style=color:#fab387>16</span>, H<span style=color:#89dceb;font-weight:700>&gt;</span>,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The <code>POP</code> instruction simply calls the <code>fn pop()</code> method of the <code>Stack</code> struct, and updates the gas costs by calling the <code>gas!</code> macro. If there is a stack underflow, it will also update the <code>InstructionResult</code>.</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rs data-lang=rs><span style=display:flex><span><span style=color:#cba6f7>pub</span> <span style=color:#cba6f7>fn</span> <span style=color:#89b4fa>pop</span><span style=color:#89dceb;font-weight:700>&lt;</span>H: <span style=color:#f9e2af>Host</span><span style=color:#89dceb;font-weight:700>&gt;</span>(interpreter: <span style=color:#cba6f7>&amp;</span><span style=color:#f9e2af>mut</span> Interpreter, _host: <span style=color:#cba6f7>&amp;</span><span style=color:#f9e2af>mut</span> H) {
</span></span><span style=display:flex><span>    <span style=color:#89b4fa>gas!</span>(interpreter, gas::<span style=color:#f9e2af>BASE</span>);
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>if</span> <span style=color:#f38ba8>let</span> <span style=color:#89dceb>Err</span>(result) <span style=color:#89dceb;font-weight:700>=</span> interpreter.stack.pop() {
</span></span><span style=display:flex><span>        interpreter.instruction_result <span style=color:#89dceb;font-weight:700>=</span> result;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>When the <code>Stack</code> struct was initially <a href=../revm-pt1/#stack>introduced in the previous article</a>, only <code>fn push()</code> and <code>fn pop()</code> were showcased. Nevertheless, another convenient method with the same base principle is available: <code>fn push_slice()</code>. This function takes an arbitrary length slice of bytes, and pushes it onto the stack, effectively pushing several words at once. Note that it is necessary to pad the last word (32 bytes) with zeros.</p><p>The push operations will push an arbitrary number of words extracted from the contract bytecode into the stack. To do so, they will leverage <code>fn push_slice()</code> to seamlessly push several values at once.</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rs data-lang=rs><span style=display:flex><span><span style=color:#cba6f7>pub</span> <span style=color:#cba6f7>fn</span> <span style=color:#89b4fa>push</span><span style=color:#89dceb;font-weight:700>&lt;</span><span style=color:#cba6f7>const</span> N: <span style=color:#f38ba8>usize</span>, H: <span style=color:#f9e2af>Host</span><span style=color:#89dceb;font-weight:700>&gt;</span>(interpreter: <span style=color:#cba6f7>&amp;</span><span style=color:#f9e2af>mut</span> Interpreter, _host: <span style=color:#cba6f7>&amp;</span><span style=color:#f9e2af>mut</span> H) {
</span></span><span style=display:flex><span>    <span style=color:#89b4fa>gas!</span>(interpreter, gas::<span style=color:#f9e2af>VERYLOW</span>);
</span></span><span style=display:flex><span>    <span style=color:#6c7086;font-style:italic>// SAFETY: When analyzing bytecode, trailing bytes are added, so it is safe.
</span></span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic></span>    <span style=color:#f38ba8>let</span> ip <span style=color:#89dceb;font-weight:700>=</span> interpreter.instruction_pointer;
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>if</span> <span style=color:#f38ba8>let</span> <span style=color:#89dceb>Err</span>(result) <span style=color:#89dceb;font-weight:700>=</span> interpreter
</span></span><span style=display:flex><span>        .stack
</span></span><span style=display:flex><span>        .push_slice(<span style=color:#cba6f7>unsafe</span> { core::slice::from_raw_parts(ip, N) })
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        interpreter.instruction_result <span style=color:#89dceb;font-weight:700>=</span> result;
</span></span><span style=display:flex><span>        <span style=color:#cba6f7>return</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    interpreter.instruction_pointer <span style=color:#89dceb;font-weight:700>=</span> <span style=color:#cba6f7>unsafe</span> { ip.add(N) };
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>PUSH0</code> is an exception, since it simply pushes a <code>U256::from(0)</code> onto the stack without having to read any bytecode.</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rs data-lang=rs><span style=display:flex><span><span style=color:#cba6f7>pub</span> <span style=color:#cba6f7>fn</span> <span style=color:#89b4fa>push0</span><span style=color:#89dceb;font-weight:700>&lt;</span>H: <span style=color:#f9e2af>Host</span>, <span style=color:#f9e2af>SPEC</span>: <span style=color:#f9e2af>Spec</span><span style=color:#89dceb;font-weight:700>&gt;</span>(interpreter: <span style=color:#cba6f7>&amp;</span><span style=color:#f9e2af>mut</span> Interpreter, _host: <span style=color:#cba6f7>&amp;</span><span style=color:#f9e2af>mut</span> H) {
</span></span><span style=display:flex><span>    <span style=color:#6c7086;font-style:italic>// Check if the EVM is configured to work with SHANGAI fork
</span></span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic></span>    <span style=color:#89b4fa>check!</span>(interpreter, <span style=color:#f9e2af>SHANGHAI</span>);
</span></span><span style=display:flex><span>    <span style=color:#89b4fa>gas!</span>(interpreter, gas::<span style=color:#f9e2af>BASE</span>);
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>if</span> <span style=color:#f38ba8>let</span> <span style=color:#89dceb>Err</span>(result) <span style=color:#89dceb;font-weight:700>=</span> interpreter.stack.push(U256::<span style=color:#f9e2af>ZERO</span>) {
</span></span><span style=display:flex><span>        interpreter.instruction_result <span style=color:#89dceb;font-weight:700>=</span> result;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Both <code>SWAP</code> and <code>DUP</code> opcodes will simply call their respective stack methods. Since these methods weren&rsquo;t explained either, we will do so now.</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rs data-lang=rs><span style=display:flex><span><span style=color:#cba6f7>impl</span> Stack {
</span></span><span style=display:flex><span>    <span style=color:#6c7086>/// Duplicates the `N`th value from the top of the stack.
</span></span></span><span style=display:flex><span><span style=color:#6c7086></span>    <span style=color:#cba6f7>pub</span> <span style=color:#cba6f7>fn</span> <span style=color:#89b4fa>dup</span><span style=color:#89dceb;font-weight:700>&lt;</span><span style=color:#cba6f7>const</span> N: <span style=color:#f38ba8>usize</span><span style=color:#89dceb;font-weight:700>&gt;</span>(<span style=color:#89dceb;font-weight:700>&amp;</span><span style=color:#cba6f7>mut</span> <span style=color:#89dceb>self</span>) -&gt; <span style=color:#89dceb>Result</span><span style=color:#89dceb;font-weight:700>&lt;</span>(), InstructionResult<span style=color:#89dceb;font-weight:700>&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#f38ba8>let</span> len <span style=color:#89dceb;font-weight:700>=</span> <span style=color:#89dceb>self</span>.data.len();
</span></span><span style=display:flex><span>        <span style=color:#cba6f7>if</span> len <span style=color:#89dceb;font-weight:700>&lt;</span> N {
</span></span><span style=display:flex><span>            <span style=color:#89dceb>Err</span>(InstructionResult::StackUnderflow)
</span></span><span style=display:flex><span>        } <span style=color:#cba6f7>else</span> <span style=color:#cba6f7>if</span> len <span style=color:#89dceb;font-weight:700>+</span> <span style=color:#fab387>1</span> <span style=color:#89dceb;font-weight:700>&gt;</span> <span style=color:#f9e2af>STACK_LIMIT</span> {
</span></span><span style=display:flex><span>            <span style=color:#89dceb>Err</span>(InstructionResult::StackOverflow)
</span></span><span style=display:flex><span>        } <span style=color:#cba6f7>else</span> {
</span></span><span style=display:flex><span>            <span style=color:#6c7086;font-style:italic>// SAFETY: check for out of bounds is done above.
</span></span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic></span>            <span style=color:#cba6f7>unsafe</span> {
</span></span><span style=display:flex><span>                <span style=color:#f38ba8>let</span> data <span style=color:#89dceb;font-weight:700>=</span> <span style=color:#89dceb>self</span>.data.as_mut_ptr();
</span></span><span style=display:flex><span>                core::ptr::copy_nonoverlapping(data.add(len <span style=color:#89dceb;font-weight:700>-</span> N), data.add(len), <span style=color:#fab387>1</span>);
</span></span><span style=display:flex><span>                <span style=color:#89dceb>self</span>.data.set_len(len <span style=color:#89dceb;font-weight:700>+</span> <span style=color:#fab387>1</span>);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#89dceb>Ok</span>(())
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6c7086>/// Swaps the topmost value with the `N`th value from the top.
</span></span></span><span style=display:flex><span><span style=color:#6c7086></span>    <span style=color:#cba6f7>pub</span> <span style=color:#cba6f7>fn</span> <span style=color:#89b4fa>swap</span><span style=color:#89dceb;font-weight:700>&lt;</span><span style=color:#cba6f7>const</span> N: <span style=color:#f38ba8>usize</span><span style=color:#89dceb;font-weight:700>&gt;</span>(<span style=color:#89dceb;font-weight:700>&amp;</span><span style=color:#cba6f7>mut</span> <span style=color:#89dceb>self</span>) -&gt; <span style=color:#89dceb>Result</span><span style=color:#89dceb;font-weight:700>&lt;</span>(), InstructionResult<span style=color:#89dceb;font-weight:700>&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#f38ba8>let</span> len <span style=color:#89dceb;font-weight:700>=</span> <span style=color:#89dceb>self</span>.data.len();
</span></span><span style=display:flex><span>        <span style=color:#cba6f7>if</span> len <span style=color:#89dceb;font-weight:700>&lt;=</span> N {
</span></span><span style=display:flex><span>            <span style=color:#cba6f7>return</span> <span style=color:#89dceb>Err</span>(InstructionResult::StackUnderflow);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#f38ba8>let</span> last <span style=color:#89dceb;font-weight:700>=</span> len <span style=color:#89dceb;font-weight:700>-</span> <span style=color:#fab387>1</span>;
</span></span><span style=display:flex><span>        <span style=color:#89dceb>self</span>.data.swap(last, last <span style=color:#89dceb;font-weight:700>-</span> N);
</span></span><span style=display:flex><span>        <span style=color:#89dceb>Ok</span>(())
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#cba6f7>pub</span> <span style=color:#cba6f7>fn</span> <span style=color:#89b4fa>dup</span><span style=color:#89dceb;font-weight:700>&lt;</span><span style=color:#cba6f7>const</span> N: <span style=color:#f38ba8>usize</span>, H: <span style=color:#f9e2af>Host</span><span style=color:#89dceb;font-weight:700>&gt;</span>(interpreter: <span style=color:#cba6f7>&amp;</span><span style=color:#f9e2af>mut</span> Interpreter, _host: <span style=color:#cba6f7>&amp;</span><span style=color:#f9e2af>mut</span> H) {
</span></span><span style=display:flex><span>    <span style=color:#89b4fa>gas!</span>(interpreter, gas::<span style=color:#f9e2af>VERYLOW</span>);
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>if</span> <span style=color:#f38ba8>let</span> <span style=color:#89dceb>Err</span>(result) <span style=color:#89dceb;font-weight:700>=</span> interpreter.stack.dup::<span style=color:#89dceb;font-weight:700>&lt;</span>N<span style=color:#89dceb;font-weight:700>&gt;</span>() {
</span></span><span style=display:flex><span>        interpreter.instruction_result <span style=color:#89dceb;font-weight:700>=</span> result;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#cba6f7>pub</span> <span style=color:#cba6f7>fn</span> <span style=color:#89b4fa>swap</span><span style=color:#89dceb;font-weight:700>&lt;</span><span style=color:#cba6f7>const</span> N: <span style=color:#f38ba8>usize</span>, H: <span style=color:#f9e2af>Host</span><span style=color:#89dceb;font-weight:700>&gt;</span>(interpreter: <span style=color:#cba6f7>&amp;</span><span style=color:#f9e2af>mut</span> Interpreter, _host: <span style=color:#cba6f7>&amp;</span><span style=color:#f9e2af>mut</span> H) {
</span></span><span style=display:flex><span>    <span style=color:#89b4fa>gas!</span>(interpreter, gas::<span style=color:#f9e2af>VERYLOW</span>);
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>if</span> <span style=color:#f38ba8>let</span> <span style=color:#89dceb>Err</span>(result) <span style=color:#89dceb;font-weight:700>=</span> interpreter.stack.swap::<span style=color:#89dceb;font-weight:700>&lt;</span>N<span style=color:#89dceb;font-weight:700>&gt;</span>() {
</span></span><span style=display:flex><span>        interpreter.instruction_result <span style=color:#89dceb;font-weight:700>=</span> result;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=memory-instructions>Memory Instructions<a hidden class=anchor aria-hidden=true href=#memory-instructions>#</a></h3><p>Memory instructions refer to those operations that are mainly related to memory manipulation or information.</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rs data-lang=rs><span style=display:flex><span><span style=color:#6c7086;font-style:italic>// Snippet of the `opcodes!` macro to showcase memory opcodes,
</span></span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic>// their mnemonic representation, and their [`Instruction`].
</span></span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic></span><span style=color:#89b4fa>opcodes!</span> {
</span></span><span style=display:flex><span>    <span style=color:#fab387>0x51</span> <span style=color:#89dceb;font-weight:700>=&gt;</span> <span style=color:#f9e2af>MLOAD</span>    <span style=color:#89dceb;font-weight:700>=&gt;</span> memory::mload,
</span></span><span style=display:flex><span>    <span style=color:#fab387>0x52</span> <span style=color:#89dceb;font-weight:700>=&gt;</span> <span style=color:#f9e2af>MSTORE</span>   <span style=color:#89dceb;font-weight:700>=&gt;</span> memory::mstore,
</span></span><span style=display:flex><span>    <span style=color:#fab387>0x53</span> <span style=color:#89dceb;font-weight:700>=&gt;</span> <span style=color:#f9e2af>MSTORE8</span>  <span style=color:#89dceb;font-weight:700>=&gt;</span> memory::mstore8,
</span></span><span style=display:flex><span>    <span style=color:#fab387>0x59</span> <span style=color:#89dceb;font-weight:700>=&gt;</span> <span style=color:#f9e2af>MSIZE</span>    <span style=color:#89dceb;font-weight:700>=&gt;</span> memory::msize,
</span></span><span style=display:flex><span>    <span style=color:#fab387>0x5E</span> <span style=color:#89dceb;font-weight:700>=&gt;</span> <span style=color:#f9e2af>MCOPY</span>    <span style=color:#89dceb;font-weight:700>=&gt;</span> memory::mcopy::<span style=color:#89dceb;font-weight:700>&lt;</span>H, <span style=color:#f9e2af>SPEC</span><span style=color:#89dceb;font-weight:700>&gt;</span>,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Generally speaking, memory-related instructions are quite straight forward thanks to the manipulation methods offered by the <code>Memory</code> struct. Those methods are &ldquo;wrappers&rdquo; around the core methods <code>fn slice()</code> (getter) and <code>fn set()</code> (setter), that handle conversions between types.</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rs data-lang=rs><span style=display:flex><span><span style=color:#6c7086;font-style:italic>// Load a memory word (32-bytes) at a given index (offset) onto the stack.
</span></span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic></span><span style=color:#cba6f7>pub</span> <span style=color:#cba6f7>fn</span> <span style=color:#89b4fa>mload</span><span style=color:#89dceb;font-weight:700>&lt;</span>H: <span style=color:#f9e2af>Host</span><span style=color:#89dceb;font-weight:700>&gt;</span>(interpreter: <span style=color:#cba6f7>&amp;</span><span style=color:#f9e2af>mut</span> Interpreter, _host: <span style=color:#cba6f7>&amp;</span><span style=color:#f9e2af>mut</span> H) {
</span></span><span style=display:flex><span>    <span style=color:#89b4fa>gas!</span>(interpreter, gas::<span style=color:#f9e2af>VERYLOW</span>);
</span></span><span style=display:flex><span>    <span style=color:#89b4fa>pop!</span>(interpreter, index);
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>let</span> index <span style=color:#89dceb;font-weight:700>=</span> <span style=color:#89b4fa>as_usize_or_fail!</span>(interpreter, index);
</span></span><span style=display:flex><span>    <span style=color:#89b4fa>memory_resize!</span>(interpreter, index, <span style=color:#fab387>32</span>);
</span></span><span style=display:flex><span>    <span style=color:#89b4fa>push!</span>(interpreter, interpreter.memory.get_u256(index));
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic>// Stores a stack word (32-bytes) at a given memory index (offset).
</span></span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic></span><span style=color:#cba6f7>pub</span> <span style=color:#cba6f7>fn</span> <span style=color:#89b4fa>mstore</span><span style=color:#89dceb;font-weight:700>&lt;</span>H: <span style=color:#f9e2af>Host</span><span style=color:#89dceb;font-weight:700>&gt;</span>(interpreter: <span style=color:#cba6f7>&amp;</span><span style=color:#f9e2af>mut</span> Interpreter, _host: <span style=color:#cba6f7>&amp;</span><span style=color:#f9e2af>mut</span> H) {
</span></span><span style=display:flex><span>    <span style=color:#89b4fa>gas!</span>(interpreter, gas::<span style=color:#f9e2af>VERYLOW</span>);
</span></span><span style=display:flex><span>    <span style=color:#89b4fa>pop!</span>(interpreter, index, value);
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>let</span> index <span style=color:#89dceb;font-weight:700>=</span> <span style=color:#89b4fa>as_usize_or_fail!</span>(interpreter, index);
</span></span><span style=display:flex><span>    <span style=color:#89b4fa>memory_resize!</span>(interpreter, index, <span style=color:#fab387>32</span>);
</span></span><span style=display:flex><span>    interpreter.memory.set_u256(index, value);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic>// Stores a stack byte at a given memory index (offset).
</span></span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic></span><span style=color:#cba6f7>pub</span> <span style=color:#cba6f7>fn</span> <span style=color:#89b4fa>mstore8</span><span style=color:#89dceb;font-weight:700>&lt;</span>H: <span style=color:#f9e2af>Host</span><span style=color:#89dceb;font-weight:700>&gt;</span>(interpreter: <span style=color:#cba6f7>&amp;</span><span style=color:#f9e2af>mut</span> Interpreter, _host: <span style=color:#cba6f7>&amp;</span><span style=color:#f9e2af>mut</span> H) {
</span></span><span style=display:flex><span>    <span style=color:#89b4fa>gas!</span>(interpreter, gas::<span style=color:#f9e2af>VERYLOW</span>);
</span></span><span style=display:flex><span>    <span style=color:#89b4fa>pop!</span>(interpreter, index, value);
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>let</span> index <span style=color:#89dceb;font-weight:700>=</span> <span style=color:#89b4fa>as_usize_or_fail!</span>(interpreter, index);
</span></span><span style=display:flex><span>    <span style=color:#89b4fa>memory_resize!</span>(interpreter, index, <span style=color:#fab387>1</span>);
</span></span><span style=display:flex><span>    interpreter.memory.set_byte(index, value.byte(<span style=color:#fab387>0</span>))
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic>// Push the memory size onto the stack.
</span></span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic></span><span style=color:#cba6f7>pub</span> <span style=color:#cba6f7>fn</span> <span style=color:#89b4fa>msize</span><span style=color:#89dceb;font-weight:700>&lt;</span>H: <span style=color:#f9e2af>Host</span><span style=color:#89dceb;font-weight:700>&gt;</span>(interpreter: <span style=color:#cba6f7>&amp;</span><span style=color:#f9e2af>mut</span> Interpreter, _host: <span style=color:#cba6f7>&amp;</span><span style=color:#f9e2af>mut</span> H) {
</span></span><span style=display:flex><span>    <span style=color:#89b4fa>gas!</span>(interpreter, gas::<span style=color:#f9e2af>BASE</span>);
</span></span><span style=display:flex><span>    <span style=color:#89b4fa>push!</span>(interpreter, U256::from(interpreter.memory.len()));
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>MCOPY</code> is a new opcode introduced in the Cancun fork that combines consecutive <code>MLOAD</code> and <code>MSTORE</code> instructions. The introduction of this new opcode allows for easier and cheaper data copy within memory locations.</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rs data-lang=rs><span style=display:flex><span><span style=color:#6c7086;font-style:italic>// EIP-5656: MCOPY - Memory copying instruction
</span></span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic></span><span style=color:#cba6f7>pub</span> <span style=color:#cba6f7>fn</span> <span style=color:#89b4fa>mcopy</span><span style=color:#89dceb;font-weight:700>&lt;</span>H: <span style=color:#f9e2af>Host</span>, <span style=color:#f9e2af>SPEC</span>: <span style=color:#f9e2af>Spec</span><span style=color:#89dceb;font-weight:700>&gt;</span>(interpreter: <span style=color:#cba6f7>&amp;</span><span style=color:#f9e2af>mut</span> Interpreter, _host: <span style=color:#cba6f7>&amp;</span><span style=color:#f9e2af>mut</span> H) {
</span></span><span style=display:flex><span>    <span style=color:#89b4fa>check!</span>(interpreter, <span style=color:#f9e2af>CANCUN</span>);
</span></span><span style=display:flex><span>    <span style=color:#89b4fa>pop!</span>(interpreter, dst, src, len);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6c7086;font-style:italic>// into usize or fail
</span></span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic></span>    <span style=color:#f38ba8>let</span> len <span style=color:#89dceb;font-weight:700>=</span> <span style=color:#89b4fa>as_usize_or_fail!</span>(interpreter, len);
</span></span><span style=display:flex><span>    <span style=color:#6c7086;font-style:italic>// deduce gas
</span></span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic></span>    <span style=color:#89b4fa>gas_or_fail!</span>(interpreter, gas::verylowcopy_cost(len <span style=color:#cba6f7>as</span> <span style=color:#f38ba8>u64</span>));
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>if</span> len <span style=color:#89dceb;font-weight:700>==</span> <span style=color:#fab387>0</span> {
</span></span><span style=display:flex><span>        <span style=color:#cba6f7>return</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>let</span> dst <span style=color:#89dceb;font-weight:700>=</span> <span style=color:#89b4fa>as_usize_or_fail!</span>(interpreter, dst);
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>let</span> src <span style=color:#89dceb;font-weight:700>=</span> <span style=color:#89b4fa>as_usize_or_fail!</span>(interpreter, src);
</span></span><span style=display:flex><span>    <span style=color:#6c7086;font-style:italic>// resize memory
</span></span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic></span>    <span style=color:#89b4fa>memory_resize!</span>(interpreter, max(dst, src), len);
</span></span><span style=display:flex><span>    <span style=color:#6c7086;font-style:italic>// copy memory in place
</span></span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic></span>    interpreter.memory.copy(dst, src, len);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=moving-forward>Moving Forward<a hidden class=anchor aria-hidden=true href=#moving-forward>#</a></h2><p>And that&rsquo;s it for this deep dive into the EVM interpreter and opcodes. We&rsquo;ve covered a lot, but there&rsquo;s always more to explore with Ethereum&rsquo;s execution engine. One major area we haven&rsquo;t touched on yet involves the host-related opcodes, which play a crucial role in how smart contracts interact with the EVM.</p><p>Because of the length of the article, I saved that discussion for next time. In our upcoming article, we will cover the host-related opcodes, while diving into contract calls and looking at sub-execution contexts. Our exploration thus far has been guided by certain simplifications and assumptions for the sake of clarity. Yet, as we venture into the intricacies of Ethereum&rsquo;s smart contract interactions and execution models, these foundational concepts will be revisited and expanded.</p><p>So, stay tuned! We&rsquo;re just scratching the surface, and there&rsquo;s plenty more to uncover about how one of the most efficient implementations ( <em>but made in rust ™️</em> ) of the EVM works under the hood. See you in the next one!</p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=next href=https://0xrusowsky.github.io/blog/articles/revm-pt1/><span class=title>Prev »</span><br><span>Ethereum Virtual Machine (in Rust) - Part 1</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://0xrusowsky.github.io/blog/>0xrusowsky</a></span>
<span>      Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>